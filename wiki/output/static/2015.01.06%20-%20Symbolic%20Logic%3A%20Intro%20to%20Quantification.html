<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="generator" content="TiddlyWiki" />
<meta name="tiddlywiki-version" content="5.1.13" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="mobile-web-app-capable" content="yes"/>
<meta name="format-detection" content="telephone=no">
<link id="faviconLink" rel="shortcut icon" href="favicon.ico">
<link rel="stylesheet" href="static.css">
<title>2015.01.06 - Symbolic Logic: Intro to Quantification: â¦—h0p3's Wikiâ¦˜ â€” â€ â€ â€â€ â€1.2.20191101 ğ–¡¶ 

 Readme

</title>
</head>
<body class="tc-body">

<section class="tc-story-river">
<p><div class="tc-tiddler-frame tc-tiddler-view-frame tc-tiddler-exists   tc-tagged-Tulane " data-tags="Tulane" data-tiddler-title="2015.01.06 - Symbolic Logic: Intro to Quantification"><div class="tc-tiddler-title">
<div class="tc-titlebar">
<span class="tc-tiddler-controls">
<span class=" tc-reveal"><button aria-label="more" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fmore-tiddler-actions" title="More actions"></button><div class=" tc-reveal" hidden="true"></div></span><span class=" tc-reveal"><button aria-label="delete" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fdelete" title="Delete this tiddler">


</button></span><span class=" tc-reveal"><button aria-label="permalink" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fpermalink" title="Set browser address bar to a direct link to this tiddler"></button></span><span class=" tc-reveal"><span class=" tc-reveal"><button aria-label="info" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Finfo" title="Show information for this tiddler">
</button></span><span class=" tc-reveal" hidden="true"></span></span><span class=" tc-reveal"><span class=" tc-reveal" hidden="true"></span></span><span class=" tc-reveal"><button aria-label="new journal here" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fnew-journal-here" title="Create a new journal tiddler tagged with this one">





</button></span><span class=" tc-reveal"><button aria-label="close others" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose-others" title="Close other tiddlers"></button></span><span class=" tc-reveal"><button aria-label="edit" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fedit" title="Edit this tiddler"></button></span><span class=" tc-reveal"><button aria-label="close" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose" title="Close this tiddler"></button></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span>
</span>

<a class="tc-tiddlylink tc-tiddlylink-resolves tc-popup-handle tc-popup-absolute" href="2015.01.06%2520-%2520Symbolic%2520Logic%253A%2520Intro%2520to%2520Quantification.html">

<span class="tc-tiddler-title-icon" style="fill:;">

</span>



<h2 class="tc-title">
2015.01.06 - Symbolic Logic: Intro to Quantification
</h2>

</a>

</div>

<div class="tc-tiddler-info tc-popup-handle tc-reveal" hidden="true"></div>
</div><div class=" tc-reveal" hidden="true"></div>
<div class=" tc-reveal">
<div class="tc-subtitle">
Edited: 2018.10.30 23:59
</div>
</div><div class=" tc-reveal">
<div class="tc-tags-wrapper"><span class="tc-tag-list-item">
<span class="tc-tag-label tc-btn-invisible" draggable="true" style="background-color:;
fill:#ffffff;
color:#ffffff;">
 Tulane
</span>
<span class="tc-drop-down tc-reveal" hidden="true"></span></span></div>
</div>

<div class="tc-tiddler-body tc-reveal"><p>22</p><p>Quantificational logic â€“ Quantifiers</p><p>We are now passing from sentential, truth-functional, propositional logic to what is known as predicate, quantified logic.</p><p>Â¬, âˆ¨, âˆ§, â†’, â†” are our logical connectives. (Truth functional connectives)</p><p>Weâ€™ll now be considering some connectives which are not truth-functional.</p><p>Sentences in English are generally a combination of a Noun phrase + verb phrase</p><p>â€œTed is dead.â€</p><p>â€œTedâ€ is the noun phrase, and â€œis deadâ€ is the verb phrase.</p><p>â€œEvery person Ted knows is alive.â€</p><p>â€œEvery person Ted knowsâ€ is the noun phrase, and â€œis aliveâ€ is the verb phrase</p><p>Sentence (1) can be handled in truth-functional, propositional logic.</p><p>Dead(ted)</p><p>Sentence (2), however, canâ€™t be handled by truth functional logic. The noun phrase is the problem. Specifically, â€œEvery personâ€ canâ€™t be captured within truth functional logic. â€œEveryâ€ is a determiner. â€œPersonâ€ is a common noun. â€œEvery personâ€ is a quantifier expression.</p><p>Example Determiners:</p><p>All, some, every, each, most, at least then</p><p>Determiner + common noun = quantifier expression</p><p>Ex: â€˜Some dogsâ€™, â€˜Each childâ€™, â€˜All catsâ€™, â€˜Most cellistsâ€™, â€˜At least ten studentsâ€™</p><p>Sentences which contain quantifier expressions are quantified sentences. Quantified sentences allow us to talk about quantities of things. The quantities of a particular circumstance help to determine the truth value of a quantified expression.</p><p>Non-Truth Functionality - Once you introduce quantifiers, you leave truth functional connectives behind in a sense. They still exist in their own realm, but quantifiers are non-truth functional.</p><p>| Every rich actor is a good actor.</p><p>| Brad Pitt is a rich actor.</p><p>| Brad Pitt is a good actor.</p><p>| Many rich actors are good actors.</p><p>| Brad Pitt is a rich actor.</p><p>| Brad Pitt is a good actor.</p><p>This is ancient (Aristotelian-style) syllogistic logic, which informally is easier to understand than the sentential, truth-functional logic weâ€™ve been working on. However, when it comes to formalizing these kinds of arguments, it will be more difficult than formal sentential logic.</p><p>The first is valid, and the second invalid. We know this by naturally thinking about them. Unfortunately, we canâ€™t prove the first with truth-functional logical connectives we have.</p><p>The problem is that we canâ€™t determine the truth of quantified sentences by looking at the truth values of its constituent sentences. These are simple sentences that canâ€™t be broken down any further. That is why quantifiers arenâ€™t truth functional, and their quantified sentences canâ€™t be fully analyzed in truth-functional connectives. In the case of these sentences, the truth values are determined by the relationship between the collection of rich actors and the collection of good actors: by whether all, none, or some of the former (rich actors) are members of the latter (good actors).</p><p>We will use 2 quantifiers:</p><p>Universal Quantifier - âˆ€ - Every, each, for all, all, everything</p><p>Existential Quantifier - âˆƒ - Some, there exists, exists, at least one, something</p><p>There are alternative notations for these quantifiers, and alternative syntax for quantifying, but I will not cover them. See Section 9.8 for that.</p><p>At this point, I think we need to categorize our symbols. Our language, Fitch, is broken into logical and non-logical symbols.</p><p>Logical Symbols:</p><p>=, Â¬, v, âˆ§, â†’, â†”, âˆ€, âˆƒ; (Individual variables) t, u, v, w, x, y, z, t1, u1, etc. (with or without subscripts)</p><p>Non-logical Symbols:</p><p>Predicate symbols, function symbols, individual constants</p><p>Lastly, I want to add that weâ€™ve also been using a category of symbols which arenâ€™t a part of the language at all.</p><p>P v ~P =&gt; &lt;=&gt;</p><p>The Pâ€™s here arenâ€™t part of Fitch. Replacing sentences with capitalized letters is a shortcut weâ€™ve been using. It allows us to ignore the meanings of sentences, to focus on the logical symbols, etc. Further, the double-bar arrows have been representing the logical notions of consequence and equivalence. These arenâ€™t a part of our language either. This is, essentially, a metalanguage â€“ a language about the Fitch language.</p><p>Variables - like individual constants, use lower case letters. a-f for constants, t-z for variables. They arenâ€™t the same though. Syntactically, variables work just like constants. Anywhere one can appear, so can the other.</p><p>Large(a), Smaller(b, c), father(george)</p><p>Wherever individual constants are grammatically acceptable, so are variables:</p><p>Large(x), Smaller(x, y), father(y)</p><p>They have the same behavior and set of rules for writing them down. They are syntactically identical. Semantically, however, they are very different. The semantic role of an individual constant: it picks out an individual thing. Variables, however, donâ€™t pick out anything in particular.</p><p>Here are some differences which fall out of that fact:</p><p>Large(x) vs. Large(a)</p><p>Large(x) is not a sentence, but Large(a) is. Recall that only sentences have truth values. Hence, Large(a) has a truth value, but Large(x) doesnâ€™t because x doesnâ€™t pick anything out.</p><p>The same issue applies to function symbols:</p><p>father(george) vs. father(x)</p><p>father(george) picks someone out (it is a referring expression), father(x) doesnâ€™t pick anyone out. We donâ€™t know who x is.</p><p>However, these are all well-formed formulas, a.k.a. wffs.</p><p>Wff - Up until now, we had defined term as something which â€œpicks out.â€ This is no longer true now that we have variables. We need to think of terms syntactically now. Terms are used with predicates and quantifiers to create well-formed formulas (wffs). Variables are simple terms (like individual constants). Complex terms, of course, are the results of function symbols applied to terms.</p><p>Atomic wff: an n-ary predicate symbol followed by n terms enclosed in parentheses and separated by commas (if necessary).</p><p>Wffs are very much like sentences; syntactically, they look like sentences, except a wff can have a free variable (in which case it doesnâ€™t actually say anything â€“ weâ€™ll get to what why this is the case later; we need our terminology first).</p><p>All atomic sentences are atomic wffs, but not the other way around. Atomic sentences are atomic wffs with no free variables. Let us call those wffs with free variables â€œmere wffsâ€. We will later define what it means to have a free variable, for now, our examples are mere wffs.</p><p>Home(joe) Between(joe, bob, george) 5 = sum(7, 3)</p><p>Home(x) Between(x, y, george) 5 = sum(u, 3)</p><p>The top row has atomic sentences, which means they are atomic wffs. The bottom row arenâ€™t sentences, but they are atomic wffs.</p><p>Importantly, you can take any atomic wff and operate on them with truth functional connectives, and the result will be a complex wff.</p><p>Home(x)</p><p>Â¬Home(x)</p><p>Home(x) âˆ¨ Â¬Home(x)</p><p>The first is an atomic wff, the second and third are complex wffs. They are all mere wffs, since they have free variables.</p><p>Syntax for quantifiers - Rules for constructing complex wffs from atomic wffs:</p><p>If P is a wff, so is Â¬P</p><p>If P1, â€¦ , Pn are wffs, so is (P1 âˆ§ â€¦ âˆ§ Pn)</p><p>If P1, â€¦ , Pn are wffs, so is (P1 âˆ¨ â€¦ âˆ¨ Pn)</p><p>If P and Q are wffs, so is (P â†’ Q)</p><p>If P and Q are wffs, so is (P â†” Q)</p><p>If P is a wff and Î½ (nu) is a variable, then âˆ€Î½P is a wff, and any occurrence of Î½ in P (of âˆ€Î½P) is said to be bound.</p><p>If P is a wff, and Î½ is a variables, then âˆƒÎ½P is a wff, and any occurrence of Î½ in P (of âˆƒÎ½P) is said to be bound</p><p>Up until now, we had been using Pâ€™s and Qâ€™s (and various other letters) as replacements for atomic and complex sentences in sentential logic. Now that we have crossed into predicate logic, that convention will no longer always be the case. P and Q, can represent non-sentences in the above rules. P and Q could be mere wffs. Pay careful attention to this change in convention, and be sure you know what P and Q could be in a given context. Sometimes we will use these letters to represent sentences, othertimes mere wffs, other times predicates, and so on.</p><p>Both of these are atomic mere wffs:</p><p>Cube(x) Dodec(y)</p><p>Our syntax rules enable us to construct complex mere wffs from these atomic ones:</p><p>Cube(x) âˆ§ Dodec(y)</p><p>P Q</p><p>By rule 2, we can see that this is also a wff (a complex one). Further, given our rules, we can take complex wffs and build even more complex ones:</p><p>(Cube(x) âˆ§ Dodec(y)) â†’ Tet(z)</p><p>P Q</p><p>Further, if this is a wff:</p><p>SameSize(x, x)</p><p>Then, by rule 7, so is:</p><p>âˆƒxSamesize(x,x)</p><p>Importantly, we will never write a quantifier without a variable.</p><p>âˆ€xHome(x) (well-formed)</p><p>âˆ€Home(x) (not well-formed)</p><p>There must be a variable associated with each quantifier, although it doesnâ€™t have to be the any of the variables found in the sentence over which the quantifier quantifies. This is possible:</p><p>âˆ€xHome(y)</p><p>Note that there is a variable attached to quantifier, x. Note, however, that the variable used in Home is not x, but rather y. y is a free variable, which means it is not bound. Bound and free are opposites.</p><p>Variables are bound when the variables in predicates are also attached to a quantifier, like this:</p><p>âˆ€xHome(x)</p><p>The first x, which belongs to the quantifiers, binds the second. This is translated/read as: â€œFor all x, x is home.â€ Because all the variables in the predicate are bound, and hence there are no free variables in this wff, then this isnâ€™t a mere wff, it is a sentence (it has a truth value).</p><p>Sentence: a wff with no free variables (if there are variables, they must be bound). A sentence is a wff which isnâ€™t a mere wff. Mere wffs cannot be evaluated, but sentences can.</p><p>âˆƒyP(x)</p><p>This is a wff, but x is not bound, it is free. This is a mere wff, and clearly, not a sentence. If there any yâ€™s, they would be bound.</p><p>âˆƒyâˆ€xP(x,y)</p><p>This is a sentence. The â€œoccurrenceâ€ (that which is in parentheses) of both x and y are bound.</p><p>Scope: Parentheses indicate the scope of a quantifier, much in the same way as a negation.</p><p>Â¬P âˆ¨ Q Â¬(P âˆ¨ Q)</p><p>âˆƒxDoctor(x) âˆ§ Smart(x) âˆƒx(Doctor(x) âˆ§ Smart(x))</p><p>We must pay very careful attention to scope. Note that the first quantifier example is not a sentence, since Smart(x) is not in the scope of the quantifier, and thus the x in Smart(x) is not bound. The second quantifier example is a sentence.</p><p>Homework: 9.1-9.3</p><p>Satisfaction for quantifiers â€“ Mere wffs donâ€™t have truth-valuesâ€”they are not true or false. Consequently, a quantified sentence that is built from mere wffs, such as âˆƒxCube(x), cannot have its truth-value defined in terms of the truth-value of its component mere wff, Cube(x), since that mere wff does not have a truth-value.</p><p>As an analogy, think of P âˆ§ Q, and letâ€™s say Q didnâ€™t have a truth value â€“ it could be neither true nor false. We couldnâ€™t then know the truth value of P âˆ§ Q in virtue of knowing the truth values of the components.</p><p>Mere wffs, although not true or false simpliciter, nevertheless can be said to be true or false of things.</p><p>Cube(x)</p><p>This mere wff isnâ€™t true or false simpliciter, however, it is true of each cube, and false of every other thing. Similarly:</p><p>Tet(x) âˆ§ Small(x)</p><p>This mere wff isnâ€™t true or false, however it is true of each small tetrahedron, and false of every other thing.</p><p>This relationship of a mere wff being true of things is called satisfaction. Instead of saying these mere true wffs are â€œtrue of,â€ we say that each cube satisfies Cube(x) and each small tetrahedron satisfies (Tet(x) âˆ§Small(x)).</p><p>Satisfaction is a relation between an object and a mere wff. Specifically, satisfaction is a relation between an ordered n-tuple of objects and a mere wff with n free variables.</p><p>Consider a mere wff with two free variables:</p><p>Larger(x, y)</p><p>Which objects stand in the satisfaction-relation to this wff? No object taken by itself does so. For example:</p><p>Larger(a, a)</p><p>Let us say x and y were substituted with a. This sentence, which is no longer a mere wff, is not true. a, as a single object, cannot satisfy the mere wff, Larger(x, y). No single object can. Rather, only pairs of objects that could satisfy this mere wff.</p><p>Consider a world in which:</p><p>a is a small cube</p><p>b is a large tetrahedron</p><p>This pair of object could satisfy the mere wff, depending on how we make the substitutions.</p><p>&lt;b, a&gt;</p><p>The pair of objects b and a, taken in that orderâ€”&lt;b, a&gt; is how we write thisâ€”satisfies the wff Larger(x, y). x is substituted by b, and y is substituted by a. Hence, the substitution looks like this:</p><p>Larger(b, a)</p><p>This sentence is true in our domain. Note that this substitution does not satisfy the mere wff:</p><p>&lt;a, b&gt;</p><p>Larger(a, b)</p><p>We can state what it is for an object to satisfy a wff in terms of the truth of a particular sentence. Take this mere wff:</p><p>S(x)</p><p>If S(x) is a mere wff containing one free variable, then a given object satisfies S(x) iff we get a true sentence when we replace every free occurrence of x in S(x) with the name of that object. For example:</p><p>Cube(x) âˆ§ Adjoins(x, a)</p><p>An object b satisfies this mere wff iff the following sentence is true:</p><p>Cube(b) âˆ§ Adjoins(b, a)</p><p>Not every object has a name. In many of the worlds in Tarskiâ€™s World, lots of objects are nameless. How do we explain what it is for a nameless object to satisfy a wff? We assign the object a temporary name and proceed as we did above for named objects. Tarskiâ€™s World reserves a number of individual constants for just this purpose:</p><p>n1, n2, n3, â€¦ nn</p><p>If we want to know whether a given nameless object satisfies a wff, we temporarily give it a name, choosing as its name the first of these constants not already in use.</p><p>Satisfaction: An object o, whether named or nameless, satisfies a wff P(x), where x is free, iff o has the property expressed by P.</p><p>o satisfies Cube(x) iff o is a cube.</p><p>o satisfies Home(x) âˆ§ Hungry(x) iff o is at home and hungry</p><p>Suppose o has no name. Then o satisfies P(x) iff P(n) is true, where n is a new name temporarily introduced into the language to name o. If n names o, think of o satisfying P(x) in terms of P(n) being true.</p><p>Domain of discourse: when we use quantifier expressions we have tacitly in mind some collection of objects in mind over which we are quantifying. A domain is a non-empty (must contain one thing) collection of objects. The domain of discourse is the entire collection of things that we take our FOL sentences to be â€œaboutâ€â€”the things we allow our quantifiers to â€œrange overâ€ or pick out. Sometimes, the domain is unrestricted, in which case we are talking about everything, and our quantifiers range over all objects. More often, the domain is restricted in some way (restricted to a smaller collection of objectsâ€”people, numbers, politicians, elementary particles, etc.). The choice of domains affects how we read the quantifiers and quantified sentences. But in any case, the domain must be non-empty. For example:</p><p>â€œEvery student took the testâ€</p><p>It is understood we arenâ€™t talking about all students around the world, rather only all the student registered for the class. The things we intuitively mean to be talking about comprise the domain.</p><p>Every quantifier must be relative to a domain.</p><p>Semantics for quantifiers:</p><p>Semantics for âˆƒ:	âˆƒxS(x) is true iff there is at least one object which satisfies S(x).</p><p>âˆƒx(Red(x) âˆ§ Truck(x))</p><p>This is true iff some object satisfies the constitutive mere wff (Red(x) âˆ§ Truck(x)). Cases where it would be true: Some trucks are red. A truck is red. I have a red truck. At least one truck is red.</p><p>âˆƒx(Cube(x) âˆ¨ Small(x))</p><p>This is true iff there is at least one object satisfying the consistutive mere wff (Cube(x) âˆ¨ Small(x)), i.e., there is at least one object which is either small or a cube.</p><p>Semantics for âˆ€:	âˆ€xS(x) is true iff every object satisfies S(x)</p><p>âˆ€x Cube(x)</p><p>This is true iff every object satisfies Cube(x), i.e. every object is a cube. If something isnâ€™t a cube in our domain, then this sentence is false.</p><p>âˆ€x(Cube(x) â†’ Small(x))</p><p>This is true iff every object satisfies (Cube(x) â†’Small(x)), i.e., every object satisfying Cube(x) also satisfies Small(x), i.e., iff every cube is small. Cases where it would be true: All cubes are small. Every cube is small. For anything you take to be a cube, it is small.</p><p>Homework: 9.5-9.6</p><p>Translations</p><p>The Aristotelian Forms:</p><p>Famous translations of English to FOL. English phrases:</p><p>â€œAll Pâ€™s are Qâ€™sâ€ âˆ€x(P(x) â†’ Q(x)) Universal Affirmative</p><p>â€œSome Pâ€™s are Qâ€™sâ€ âˆƒx(P(x) âˆ§ Q(x)) Particular Affirmative</p><p>â€œNo Pâ€™s are Qâ€™sâ€ âˆ€x(P(x) â†’ Â¬Q(x)) â‡” Â¬âˆƒx(P(x) âˆ§ Q(x)) Universal Negative</p><p>â€œSome Pâ€™s are not Qâ€™sâ€ âˆƒx(P(x) âˆ§ Â¬Q(x)) Particular Negative</p><p>If you understand the affirmatives, then you can easily get the negatives. Weâ€™re just tacking on a negation on the Q, but otherwise the negatives have the same form, overall, as their corresponding affirmatives.</p><p>â€œEvery even number is prime.â€ âˆ€x(Even(x) â†’ Prime(x))</p><p>â€œSome prime is even.â€ âˆƒx(Prime(x) âˆ§ Even(x))</p><p>â€œNo even number is prime.â€ âˆ€x(Even(x) â†’ Â¬Prime(x))</p><p>â€œThere is a prime which is not even.â€ âˆƒx(Prime(x) âˆ§ Â¬Even(x))</p><p>Noun phrases naturally translated using the existential quantifier typically start with a determiner such as â€œa,â€ â€œan,â€ or â€œsome.â€</p><p>â€œA man on the bus faintedâ€</p><p>â€œSome man on the bus fainted.â€</p><p>Some Pâ€™s are Qâ€™s</p><p>âˆƒx(P(x) âˆ§ Q(x))</p><p>âˆƒx(Man(x) âˆ§ Bus(x) âˆ§ Fainted(x))</p><p>P(x) Q(x)</p><p>â€œMax owns a small, happy dog.â€</p><p>â€œSome small, happy dog is owned by Max.â€</p><p>Some Pâ€™s are Qâ€™s</p><p>âˆƒz(P(z) âˆ§ Q(z))</p><p>âˆƒz(Small(z) âˆ§ Happy(z) âˆ§ Dog(z) âˆ§ Owns(max, z))</p><p>P(z) Q(z)</p><p>â€œA lawyer didnâ€™t eat.â€</p><p>Some Pâ€™s are not Qâ€™s</p><p>âˆƒy(P(y) âˆ§ Â¬Q(y))</p><p>âˆƒy(Lawyer(y) âˆ§ Â¬Ate(y))</p><p>P(y) Q(y)</p><p>We wonâ€™t always need to use the Aristotelian form:</p><p>â€œNothing is in front of b.â€</p><p>â€œNo things are in front of b.â€</p><p>No Pâ€™s are Qâ€™s</p><p>Â¬âˆƒx(FrontOf(x, b)) â‡” âˆ€x(Â¬FrontOf(x, b))</p><p>Noun phrases naturally translated using the universal quantifier typically starts with a determiner such as â€œall,â€ â€œevery,â€ or â€œeach.â€</p><p>â€œEvery man on the bus fainted.â€</p><p>All Pâ€™s are Qâ€™s</p><p>âˆ€x(P(x) â†’ Q(x))</p><p>âˆ€x((Man(x) âˆ§ Bus(x)) â†’ Fainted(x))</p><p>P(x) Q(x)</p><p>â€œClaire knows every member of congress.â€</p><p>All Pâ€™s are Qâ€™s</p><p>âˆ€z(P(z) â†’ Q(z))</p><p>âˆ€z(Congress(z) â†’ Knows(claire, z))</p><p>P(z) P(z)</p><p>â€œThere are no medium-sized cubesâ€</p><p>No Pâ€™s are Qâ€™s</p><p>âˆ€x(P(x) â†’ Â¬Q(x)) â‡” Â¬âˆƒx(P(x) âˆ§ Q(x))</p><p>âˆ€x(Cube(x) â†’ Â¬Medium(x)) â‡” Â¬âˆƒx(Cube(x) âˆ§ Â¬Medium(x))</p><p>P(x) Q(x) P(x) Q(x)</p><p>â€œEvery cube is in front of or in back of eâ€</p><p>âˆ€x(Cube(x) â†’ (FrontOf(x, e) âˆ¨ BackOf(x, e)))</p><p>P(x) Q(x)</p><p>â€œNo cube is between a and c.â€</p><p>âˆ€x(Cube(x) â†’ Â¬Between(x, a, c))</p><p>P(x) Q(x)</p><p>Some sentences just donâ€™t nicely fit the Aristotelian form:</p><p>â€œEverything is in the same column as a, b, or c.â€</p><p>âˆ€x(SameCol(x, a) âˆ¨ SameCol(x, b) âˆ¨ SameCol(x, c))</p><p>Unintuitive strength of Conditionals and Conjunctions:</p><p>Youâ€™ve probably noticed that we are using conditionals for the universal quantifier, and using conjunctions for the existential quantifier, at least so far. This may seem wrong to some your intuitions. Consider what would happen if we didnâ€™t do it this way for the Aristotelian forms:</p><p>âˆ€x(P(x) â†’ Q(x)) Everything which is P is Q.</p><p>âˆ€x(P(x) âˆ§ Q(x)) Everything is both P and Q.</p><p>The second sentence is very strong. All objects must satisfy the mere wff (P(x) âˆ§ Q(x)) in order for âˆ€x(P(x) âˆ§ Q(x)) to be true.</p><p>âˆƒx(P(x) âˆ§ Q(x)) Something is both P and Q.</p><p>âˆƒx(P(x) â†’ Q(x)) Something is such that if it is P, then it is Q.</p><p>The second sentence is very weak. Some object must simply satisfy (P(x) â†’ Q(x)) in order for âˆƒx(P(x) â†’ Q(x)) to be true. Recall that the conditional is only false when the antecedent is true and the consequent false. If the antecedent is false of an object, then the conditional is true of the object.</p><p>An easy way to see whatâ€™s wrong with this translation into FOL is to remember that P â†’ Q is equivalent to Â¬P âˆ¨ Q.</p><p>âˆƒx (P(x) â†’ Q(x)) â‡” âˆƒx (Â¬P(x) âˆ¨ Q(x)).</p><p>Now compare these 3 sentences:</p><p>Some cubes are large. âˆƒx(Cube(x) âˆ§ Large(x)) Something is not a cube or it is large. âˆƒx(Â¬Cube(x) âˆ¨ Large(x)) Something is such that if it is a cube, then it is large. âˆƒx(Cube(x) â†’ Large(x))</p><p>Two ways of writing â€œNo Pâ€™s are Qâ€™sâ€:</p><p>Universal generalization:</p><p>English: â€œfor any object, if itâ€™s P, then itâ€™s not Q.â€</p><p>FOL: âˆ€x (P(x) â†’ Â¬Q(x))</p><p>Negation:</p><p>English: â€œit is false that even one P is a Q.â€</p><p>FOL: Â¬âˆƒx(P(x) âˆ§ Q(x)).</p><p>These are both correct and perfectly acceptable ways of translating the â€œNo Pâ€™s are Qâ€™sâ€ sentences into FOL.</p><p>All vs. Only - Notice that just as all can be a quantifier in English (as in the phrase all freshmen), so too can only be used as a quantifier (as in only freshmen). Compare the following two sentences:</p><p>All freshmen are eligible for the prize.</p><p>Only freshmen are eligible for the prize.</p><p>(1) tells us that being a freshman is a sufficient condition for eligibilityâ€”if youâ€™re a freshman, then youâ€™re eligible. But (2) tells us that being a freshman is a necessary condition for eligibilityâ€”youâ€™re eligible only if youâ€™re a freshman. Hence, our two sentences go into FOL as follows:</p><p>âˆ€x (Freshman(x) â†’ Eligible(x))</p><p>âˆ€x (Eligible(x) â†’ Freshman(x))</p><p>Homework: 9.8-9.9, 9.12-9.14 (Donâ€™t forget 09.1, Aristotelian Translations hand-out)</p><p>Vacuously True Sentences:</p><p>All Pâ€™s are Qâ€™s âˆ€x(P(x) â†’ Q(x))</p><p>This is true if there are no Pâ€™s. Every object in the domain satisfies that wff, namely P(x) â†’ Q(x). For any object in the domain, if a names that object, then the sentence P(a) â†’ Q(a) is true.</p><p>P(x) â†’ Q(x) â‡” Â¬P(x) âˆ¨ Q(x)</p><p>â‡” Â¬P(a) is true or Q(a) is true</p><p>â‡” P(a) is false or Q(a) is true</p><p>If there are no Pâ€™s, the claim that all Pâ€™s have some further property is true. âˆ€x(P(x) â†’ Q(x)) is false iff there is at least one object o in the domain such that o is P, but not Q.</p><p>Vacuity:</p><p>âˆ€x(P(x) â†’ Q(x))</p><p>A sentence of this form which is true merely because there are no Pâ€™s in the domain is said to be vacuously true.</p><p>Some sentences can only be vacuously true. Any sentence of the same form, âˆ€x(P(x) â†’ Q(x)), which is never true unless it is vacuously true is said to be inherently vacuous.</p><p>âˆ€x(Cube(x) â†’ Tet(x))</p><p>No Cube is a Tet. Clearly, by the meanings of the predicates, the mere wff (Cube(x) â†’ Tet(x)) can never be satisfied in a domain with a cube it, and hence the quantified sentence is false in any domain with a cube in it. However, if we limit our domain to only have objects which arenâ€™t cubes, then this is vacuously true. Since it can be only true when it is vacuously true, it is inherently vacuous.</p><p>Conversational Implicature and Quantifiers:</p><p>âˆ€x(P(x) â†’ Q(x))</p><p>This sentence will sometimes conversationally imply that there are some Pâ€™s. For example:</p><p>â€œEvery student who asked for help received it. â€œ</p><p>This has conversational implicature. It implies that there were actually students who had asked for help, which isnâ€™t necessarily true. One can say, â€œbut no student asked for helpâ€ without contradicting the previous statement.</p><p>âˆƒx(P(x) âˆ§ Q(x))</p><p>This sentence can conversationally imply that not every P is Q. For example:</p><p>â€œSome students passed the test.â€</p><p>There is a strong suggestion here that not everyone passed the test, as if some students failed the test. This isnâ€™t necessarily true though. Perhaps all students passed the test, and we could still say the above without contradicting ourselves.</p><p>Homework: 9.15-9.19</p><hr><p>FOL translations of common English phrasings of Aristotelian forms and Biconditionals:</p><p>âˆ€x(F(x) â†’ G(x))</p><p>All Fâ€™s are Gâ€™s.</p><p>Every F is a G.</p><p>Each F is a G.</p><p>Anything that is an F is a G.</p><p>If anything is an F, itâ€™s a G.</p><p>Whatever is an F is (also) a G.</p><p>Nothing is an F unless itâ€™s (also) a G.</p><p>Only Gâ€™s are Fâ€™s.</p><p>Something is an F only if itâ€™s a G.</p><p>If something is an F, it is a G.</p><p>An F is a G. [Some sentences only]</p><p>Fâ€™s are all Gâ€™s.</p><p>A thing is a G if itâ€™s an F.</p><p>âˆƒx(F(x) âˆ§ G(x))</p><p>Some Fâ€™s are Gâ€™s.</p><p>Something is both F and G.</p><p>There are GFâ€™s.</p><p>GFâ€™s exist.</p><p>An F is a G. [Some sentences only]</p><p>âˆ€x(F(x) â†’ Â¬G(x)) or Â¬âˆƒx(F(x) âˆ§ G(x))</p><p>No Fâ€™s are Gâ€™s.</p><p>Nothing which is an F is a G.</p><p>Nothing is both F and G.</p><p>No F is a G.</p><p>Not even one F is a G.</p><p>âˆƒx(F(x) âˆ§ Â¬G(x))</p><p>Some Fâ€™s are not Gâ€™s.</p><p>Some things that are F are not G.</p><p>There are Fâ€™s that arenâ€™t G.</p><p>Fâ€™s exist that are not G.</p><p>âˆ€x(F(x) â†” G(x))</p><p>All and only Fâ€™s are Gâ€™s.</p><p>Each thing is an F if, and only if, itâ€™s G.</p><p>A thing is F if, and only if, itâ€™s G.</p><p>Something is F just in case itâ€™s G.</p><p>âˆ€x(F(x) â†” Â¬ G(x))</p><p>All things except Fâ€™s are Gâ€™s.</p><p>All things except Gâ€™s are Fâ€™s.</p><p>A thing is an F just in case itâ€™s not a G.</p><p>FOL Equivalences of Aristotelian forms and the Biconditionals:</p><p>All Fâ€™s are Gâ€™s</p><p>âˆ€x(F(x) â†’ G(x))</p><p>Â¬âˆƒx(F(x) âˆ§ Â¬G(x))</p><p>âˆ€x(Â¬G(x) â†’ Â¬F(x))</p><p>âˆ€x(Â¬F(x) âˆ¨ G(x))</p><p>Some Fâ€™s are Gâ€™s.</p><p>âˆƒx(F(x) âˆ§ G(x))</p><p>âˆƒx(G(x) âˆ§ F(x))</p><p>Â¬âˆ€x(F(x) â†’ Â¬G(x))</p><p>No Fâ€™s are Gâ€™s.</p><p>âˆ€x(F(x) â†’ Â¬G(x))</p><p>Â¬âˆƒx(F(x) âˆ§ G(x))</p><p>âˆ€x(G(x) â†’ Â¬F(x))</p><p>Some Fâ€™s are not Gâ€™s.</p><p>âˆƒx(F(x) âˆ§ Â¬G(x))</p><p>âˆƒx(Â¬G(x) âˆ§ F(x))</p><p>Â¬âˆ€x(F(x) â†’ G(x))</p><p>All and only Fâ€™s are Gâ€™s.</p><p>âˆ€x(F(x) â†” G(x))</p><p>âˆ€x(G(x) â†” F(x))</p><p>All things except Fâ€™s are Gâ€™s.</p><p>âˆ€x(F(x) â†” Â¬ G(x))</p><p>âˆ€x(Â¬F(x) â†” G(x))</p></div>



</div>

</p>
</section>
</body>
</html>
