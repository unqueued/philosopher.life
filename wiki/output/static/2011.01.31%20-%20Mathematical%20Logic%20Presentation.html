<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="generator" content="TiddlyWiki" />
<meta name="tiddlywiki-version" content="5.1.13" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="mobile-web-app-capable" content="yes"/>
<meta name="format-detection" content="telephone=no">
<link id="faviconLink" rel="shortcut icon" href="favicon.ico">
<link rel="stylesheet" href="static.css">
<title>2011.01.31 - Mathematical Logic Presentation: ‚¶óh0p3's Wiki‚¶ò ‚Äî ‚Äç ‚Äç ‚Äç‚Äç ‚Äç1.2.20191101 ñ°∂ 

 Readme

</title>
</head>
<body class="tc-body">

<section class="tc-story-river">
<p><div class="tc-tiddler-frame tc-tiddler-view-frame tc-tiddler-exists   tc-tagged-LSU " data-tags="LSU" data-tiddler-title="2011.01.31 - Mathematical Logic Presentation"><div class="tc-tiddler-title">
<div class="tc-titlebar">
<span class="tc-tiddler-controls">
<span class=" tc-reveal"><button aria-label="more" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fmore-tiddler-actions" title="More actions"></button><div class=" tc-reveal" hidden="true"></div></span><span class=" tc-reveal"><button aria-label="delete" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fdelete" title="Delete this tiddler">


</button></span><span class=" tc-reveal"><button aria-label="permalink" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fpermalink" title="Set browser address bar to a direct link to this tiddler"></button></span><span class=" tc-reveal"><span class=" tc-reveal"><button aria-label="info" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Finfo" title="Show information for this tiddler">
</button></span><span class=" tc-reveal" hidden="true"></span></span><span class=" tc-reveal"><span class=" tc-reveal" hidden="true"></span></span><span class=" tc-reveal"><button aria-label="new journal here" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fnew-journal-here" title="Create a new journal tiddler tagged with this one">





</button></span><span class=" tc-reveal"><button aria-label="close others" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose-others" title="Close other tiddlers"></button></span><span class=" tc-reveal"><button aria-label="edit" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fedit" title="Edit this tiddler"></button></span><span class=" tc-reveal"><button aria-label="close" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose" title="Close this tiddler"></button></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span>
</span>

<a class="tc-tiddlylink tc-tiddlylink-resolves tc-popup-handle tc-popup-absolute" href="2011.01.31%2520-%2520Mathematical%2520Logic%2520Presentation.html">

<span class="tc-tiddler-title-icon" style="fill:;">

</span>



<h2 class="tc-title">
2011.01.31 - Mathematical Logic Presentation
</h2>

</a>

</div>

<div class="tc-tiddler-info tc-popup-handle tc-reveal" hidden="true"></div>
</div><div class=" tc-reveal" hidden="true"></div>
<div class=" tc-reveal">
<div class="tc-subtitle">
Edited: 2018.10.30 23:59
</div>
</div><div class=" tc-reveal">
<div class="tc-tags-wrapper"><span class="tc-tag-list-item">
<span class="tc-tag-label tc-btn-invisible" draggable="true" style="background-color:;
fill:#ffffff;
color:#ffffff;">
 LSU
</span>
<span class="tc-drop-down tc-reveal" hidden="true"></span></span></div>
</div>

<div class="tc-tiddler-body tc-reveal"><p>1.7</p><p>The notion of truth in a structure is extremely important. After all, we are ultimately interested in notions like validity and logical consequence, both of which have to do with truth. For instance, a sentence C is a logical consequence of premises P 1 , P 2 , . . . , P 3 just in case C is true in every structure in which P 1 , P 2 , . . . , P 3 are all true.</p><p>A structure is an interpretation or model of a language: it determines what individuals the constants refer to, and what functions and relations the function symbols and relation symbols express. Keep in mind that functions and relations are just sets of n-tuples of individuals in the universe of the structure. So knowing what function or relation is expressed amounts to knowing what the value of the function is for every argument, and knowing which objects the relation relates. So, for instance, if we specify the relation that a two-place relation symbol Larger expresses, then this tells us, not that ‚ÄúLarger‚Äù has to do with size, but which objects in our universe are larger than which other objects. Once we know what we are talking about, we should be able to determine whether what we are saying is true.</p><p>However, making the idea of truth in a structure clear and precise will require several deÔ¨Ånitions. One thing that makes the matter more complex is that we will deÔ¨Åne truth not only for sentences, but also for formulas. A formula is not true or false simpliciter. Consider (in the language of Tarski‚Äôs World) the formula Larger(x,y). Both variables in this formula are free, not bound by a quantiÔ¨Åer. So it doesn‚Äôt make any sense to talk about the formula as being true or false: the variables do not refer to any object in particular (that‚Äôs why they are called ‚Äúvariables‚Äù), and are not bound by quantiÔ¨Åers, so the formula doesn‚Äôt say anything determinate (it does not ‚Äúexpress a complete thought,‚Äù as sentences are supposed to do). So how can we deÔ¨Åne truth in a structure for formulas? We can do it only by relativizing it to an assignment of objects to variables. Satisfaction is the description of truth in a formula. Suppose we have two objects: a, which is large, and b, which is small. Then we can say that ‚ÄòLarger(x, y)‚Äô is true or ‚Äúsatisfied‚Äù relative to the assignment {(x, a) ,( y, b)} , but false relative to the assignments {(x, b) , (y, a)} , {(x, a ), (y, a)} , and {(x, b ), (y, b)} . (Usually we will express this by saying that the assignment just speciÔ¨Åed satisÔ¨Åes the formula.) This is the idea that the Ô¨Årst few deÔ¨Ånitions will make precise.</p><p>1.7.1</p><p>Show Definition</p><p>Leary notes that variable assignment functions need not be injective or bijective.</p><p>A function is injective if it does not give the same value for more than one argument. Recall that no function gives more than one value for a given argument. Putting these two things together, we see that an injective function must be one-to-one: for each argument, there is only one value, and for each value, there is only one argument. A function is said to be surjective if it is ‚Äúonto,‚Äù that is, if every item in the range (or ‚Äúcodomain‚Äù) of the function is a value of the function for some argument. A function is said to be bijective if it is both injective and surjective, that is, both one-to-one and onto. So the point here is that variable assignment functions need not determine a diÔ¨Äerent value for each argument, and also need not take every element of A as its value for some argument.</p><p>We write ‚Äòf : A ‚Üí B‚Äô to mean a function from A into B.</p><p>Function Into</p><p>s: Vars symbols of L ‚Üí elements of universe A</p><p>Leary gives us an example variable assignment function while working in the Language of number theory, using the standard structure.</p><p>Show s(vi) = i</p><p>With argument v¬≠i input into variable assignment function s, the value ‚Äòi‚Äô, an element of universe A is output. This variable assignment function maps vi to element i. There are many possible variable assignment functions in this structure. He gives us another example:</p><p>Show s‚Äô(vi) = the smallest prime number that does not divide i.</p><p>So far we‚Äôre just assigning an object to each distinct variable. We aren‚Äôt yet considering how we will use this assignment to discuss truth of a formula relative to an assignment. Next we introduce a notation for taking a variable assignment function s and changing it for a single variable.</p><p>1.7.2</p><p>Show Definition, example, definition</p><p>Consider the assignment function s that I informally mentioned earlier: {(x, a ), (y, b)}. Now suppose we want to modify this function so that both variables are assigned element a of the universe. We can write this modiÔ¨Åed variable assignment function like this: s[x | b]. Then s(x) = a, but s[x | b](x) = b. On the other hand, s(y) = b and s[x | b](y) = b. Since the modiÔ¨Åcation aÔ¨Äects only the variable x, applying the modiÔ¨Åed variable assignment function to y gives us the same results as applying the original variable assignment function to y.</p><p>We are gradually closing in on a deÔ¨Ånition of truth of a formula relative to an assignment. If we have a formula with some free variables, then assigning an element from the domain to each free variable will suÔ¨Éce to determine the interpretation of all the terms. There are three kinds of terms: constants, variables, and function symbols followed by terms. Constants already have an interpretation assigned by the structure itself, so they are taken care of. The variables are taken care of by the variable assignment function s. This leaves only the complex terms constructed out of function symbols and other terms. But once the interpretation of constants and variables are taken care of, the complex terms are taken care of also. Each term ti that follows a function symbol is a constant, variable, or complex term. If it is a variable or a constant, it is taken care of already. If it is a complex term, we look at its constituent terms. Recursively following this procedure, we eventually reach function symbols all of whose terms have interpretations. Then we read the interpretation of the function symbol followed by those terms oÔ¨Ä the structure. Then we return to the next higher level of our recursive process and proceed to examine the next term. Eventually we will have an interpretation for every term in our formula.</p><p>Now would be a good time to have an example, but I don‚Äôt have one.</p><p>So we can take a variable assignment function, together with facts determined by the structure itself, and extend that variable assignment function to construct a more general term assignment function.</p><p>1.7.3</p><p>Show definition</p><p>Now we can (Ô¨Ånally) deÔ¨Åne what it is for a formula to be true relative to a variable assignment function. The usual term for truth relative to an assignment is satisfaction: we say that an assignment s satisÔ¨Åes a formula, or, in the language of the next deÔ¨Ånition, that a structure satisÔ¨Åes a formula with a particular assignment.</p><p>1.7.4</p><p>Show Definition</p><p>This deÔ¨Ånition is where we attach meanings to the logical symbols in L. The structure gives the meaning of the constant symbols, function symbols, and relation symbols, while the deÔ¨Ånition of satisfaction above essentially gives the meaning of the symbols that are common to all Ô¨Årst-order languages. These don‚Äôt need to be given in the structure for the same reason that the logical symbols don‚Äôt need to be listed when we specify a language: since they are common to all Ô¨Årst-order languages, we can leave them out of the structures, which merely give the semantics of the symbols that can change from language to language.</p><p>Notice that the notion of an x-modiÔ¨Åcation of a variable assignment function comes in handy in the fifth clause. If we have a quantiÔ¨Åed sentence, we don‚Äôt care what entity s assigns to occurrences of the variable that are bound by its quantiÔ¨Åer. For example, if we have the formula (‚àÄx)Larger(x, y) and an assignment function s = {(x, a ), (y, b)} and we want to know whether the assignment function satisÔ¨Åes the formula, then we need to appeal to the function s to Ô¨Ånd how to interpret y, which is free, but the fact that s assigns a to x is irrelevant, because the quantiÔ¨Åer tells us that the whole formula is true only if the subformula after the quantiÔ¨Åer is true for every assignment of an object to x. The notation s[x | a] gives us a convenient way to consider assignments that keep all of the assignments of s except its assignment to x.</p><p>1.7.9</p><p>We are almost ready, Ô¨Ånally, to say what it means for a sentence to be true in a structure. I‚Äôm going to go slightly out of order, starting with 1.7.9, and then working a bit backwards. First, we deÔ¨Åne what it is for a structure to be a model of a formula.</p><p>Show Definition</p><p>The double turnstile symbol ‚Äò|=‚Äô is rather versatile! The right-hand side can be either a structure, a formula or a set of formulas.</p><p>Informally, the basic idea is that a structure is a model of a formula if the formula must be true in the structure, i.e. if the formula comes out true no matter what terms you substitute for its free variables.</p><p>Of course, sentences are special cases of formulas. In the case of sentences, it makes no diÔ¨Äerence what assignment function s we use. Why? Because sentences have no free variables, and assignment functions have no eÔ¨Äect on bound variables. So if there is any assignment function s for which Fraktur A |= œÜ[s] in the special case in which œÜ is a sentence, then, since it makes no diÔ¨Äerence what assignment function we use, œÜ will be true for every assignment function, and hence we can simply say that Fraktur A |= œÜ, period.</p><p>To make it obvious when we are dealing with formulas that are also sentences, we will use a diÔ¨Äerent Greek variable for sentences, ‚ÄòœÉ‚Äô. (Notice the alliterative choice of Greek letters: phi, with its initial ‚Äòf‚Äô sound, for formulas, and sigma, with its initial ‚Äòs‚Äô sound, for sentences.)</p><p>1.7.5</p><p>DeÔ¨Ånition: If œÉ is a sentence, then we say that œÉ is true in Fraktur A if and only if Fraktur A |= œÉ, which in turn is the case if and only if there is any assignment function s for which Fraktur A |= œÉ[s].</p><p>Notice that a structure models a formula if and only if the sentence that results from preÔ¨Åxing to the formula universal quantiÔ¨Åers binding all the free variables of the formula results in a sentence that is true in the structure.</p><p>1.8</p><p>Fraktur A = AxEy ~(x = y)</p><p>This sentence is true if the structure of Fraktur A is such that the domain A has at least two elements. If we replace variable x with variable u, then it is still true. Notice, however, that if we replace x with y, then it is always false, in any structure.</p><p>Substitutability relies upon substituting variables with terms in such a way that nothing bad will happen when we do. Substituting x with y, makes bad things happen. What would be true in a domain of 2 or more is now made false with this substitution. We must avoid this. In learning to avoid this problem, Leary provides us formal rules for when and where we can substitute.</p><p>1.8.1</p><p>Show definition</p><p>When u is x, then ‚Äòu with x replaced by t‚Äô is t.</p><p>When ‚Äòu is variable not equal to x‚Äô or when ‚Äòu is a constant symbol‚Äô, then ‚Äòu with x replaced by t‚Äô is u.</p><p>With variables and constants handled, we are able to recursively define substitution for functions.</p><p>With the definition of substitution for variables, constants, and functions, we are then in a position to recursively define substitution into a formula, similar to how term assignment functions led to recursive definitions of satisfaction.</p><p>1.8.2</p><p>1.8</p><p>Fraktur A = AxEy ~(x = y)</p><p>This sentence is true if the structure of Fraktur A is such that the domain A has at least two elements. If we replace variable x with variable u, then it is still true. Notice, however, that if we replace x with y, then it is always false, in any structure.</p><p>Substitutability relies upon substituting variables with terms in such a way that nothing bad will happen when we do. Substituting x with y, makes bad things happen. We must avoid this. In avoiding this problem, Leary provides us formal rules for when and where we can substitute.</p><p>1.8.1</p><p>Show definition</p><p>When u is x, then ‚Äòu with x replaced by t‚Äô is t.</p><p>When ‚Äòu is variable not equal to x‚Äô or when ‚Äòu is a constant symbol‚Äô, then ‚Äòu with x replaced by t‚Äô is u.</p><p>With variables and constants handled, we are able to recursively define substitution for functions.</p><p>With the definition of substitution for variables, constants, and functions, we are then in a position to recursively define substitution into a formula, similar to how term assignment functions led to recursive definitions of satisfaction.</p><p>1.8.2</p><p>Show Definition</p><p>1.8.3</p><p>Show Definition</p><p>1.9.1</p><p>Show Definition</p><p>If we restrict ourselves to sentences for a moment, we can say that one set of sentences Œî logically implies another set of sentences Œì if and only if every structure in which all the sentences Œî are true is a structure in which all the sentences in Œì are true. Equivalently, we can say that Œî logically implies Œì if and only if every model of Œî is also a model of Œì.</p><p>Still another way to say the same thing: sometimes structures are called interpretations, and a model of a sentence is called an interpretation in which the sentence is true. So we can say that Œî logically implies Œì iÔ¨Ä every interpretation that makes all the sentences in Œî true also makes all the sentences in Œì true.</p><p>It is a short step to the notion of a valid argument: an argument from a set of premises Œì to a conclusion C is valid iÔ¨Ä Œì | = C.</p><p>The term ‚Äòvalid‚Äô is also used for a property of individual formulas. This usage is deÔ¨Åned in Leary‚Äôs DeÔ¨Ånition 1.9.2.</p><p>1.9.2</p><p>Show Definition</p></div>



</div>

</p>
</section>
</body>
</html>
