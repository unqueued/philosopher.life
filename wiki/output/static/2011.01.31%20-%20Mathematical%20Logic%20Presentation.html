<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="generator" content="TiddlyWiki" />
<meta name="tiddlywiki-version" content="5.1.13" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="mobile-web-app-capable" content="yes"/>
<meta name="format-detection" content="telephone=no">
<link id="faviconLink" rel="shortcut icon" href="favicon.ico">
<link rel="stylesheet" href="static.css">
<title>2011.01.31 - Mathematical Logic Presentation: â¦—h0p3's Wikiâ¦˜ â€” â€ â€ â€â€ â€1.2.20191101 ğ–¡¶ 

 Readme

</title>
</head>
<body class="tc-body">

<section class="tc-story-river">
<p><div class="tc-tiddler-frame tc-tiddler-view-frame tc-tiddler-exists   tc-tagged-LSU " data-tags="LSU" data-tiddler-title="2011.01.31 - Mathematical Logic Presentation"><div class="tc-tiddler-title">
<div class="tc-titlebar">
<span class="tc-tiddler-controls">
<span class=" tc-reveal"><button aria-label="more" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fmore-tiddler-actions" title="More actions"></button><div class=" tc-reveal" hidden="true"></div></span><span class=" tc-reveal"><button aria-label="delete" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fdelete" title="Delete this tiddler">


</button></span><span class=" tc-reveal"><button aria-label="permalink" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fpermalink" title="Set browser address bar to a direct link to this tiddler"></button></span><span class=" tc-reveal"><span class=" tc-reveal"><button aria-label="info" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Finfo" title="Show information for this tiddler">
</button></span><span class=" tc-reveal" hidden="true"></span></span><span class=" tc-reveal"><span class=" tc-reveal" hidden="true"></span></span><span class=" tc-reveal"><button aria-label="new journal here" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fnew-journal-here" title="Create a new journal tiddler tagged with this one">





</button></span><span class=" tc-reveal"><button aria-label="close others" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose-others" title="Close other tiddlers"></button></span><span class=" tc-reveal"><button aria-label="edit" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fedit" title="Edit this tiddler"></button></span><span class=" tc-reveal"><button aria-label="close" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose" title="Close this tiddler"></button></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span>
</span>

<a class="tc-tiddlylink tc-tiddlylink-resolves tc-popup-handle tc-popup-absolute" href="2011.01.31%2520-%2520Mathematical%2520Logic%2520Presentation.html">

<span class="tc-tiddler-title-icon" style="fill:;">

</span>



<h2 class="tc-title">
2011.01.31 - Mathematical Logic Presentation
</h2>

</a>

</div>

<div class="tc-tiddler-info tc-popup-handle tc-reveal" hidden="true"></div>
</div><div class=" tc-reveal" hidden="true"></div>
<div class=" tc-reveal">
<div class="tc-subtitle">
Edited: 2018.10.30 23:59
</div>
</div><div class=" tc-reveal">
<div class="tc-tags-wrapper"><span class="tc-tag-list-item">
<span class="tc-tag-label tc-btn-invisible" draggable="true" style="background-color:;
fill:#ffffff;
color:#ffffff;">
 LSU
</span>
<span class="tc-drop-down tc-reveal" hidden="true"></span></span></div>
</div>

<div class="tc-tiddler-body tc-reveal"><p>1.7</p><p>The notion of truth in a structure is extremely important. After all, we are ultimately interested in notions like validity and logical consequence, both of which have to do with truth. For instance, a sentence C is a logical consequence of premises P 1 , P 2 , . . . , P 3 just in case C is true in every structure in which P 1 , P 2 , . . . , P 3 are all true.</p><p>A structure is an interpretation or model of a language: it determines what individuals the constants refer to, and what functions and relations the function symbols and relation symbols express. Keep in mind that functions and relations are just sets of n-tuples of individuals in the universe of the structure. So knowing what function or relation is expressed amounts to knowing what the value of the function is for every argument, and knowing which objects the relation relates. So, for instance, if we specify the relation that a two-place relation symbol Larger expresses, then this tells us, not that â€œLargerâ€ has to do with size, but which objects in our universe are larger than which other objects. Once we know what we are talking about, we should be able to determine whether what we are saying is true.</p><p>However, making the idea of truth in a structure clear and precise will require several deï¬nitions. One thing that makes the matter more complex is that we will deï¬ne truth not only for sentences, but also for formulas. A formula is not true or false simpliciter. Consider (in the language of Tarskiâ€™s World) the formula Larger(x,y). Both variables in this formula are free, not bound by a quantiï¬er. So it doesnâ€™t make any sense to talk about the formula as being true or false: the variables do not refer to any object in particular (thatâ€™s why they are called â€œvariablesâ€), and are not bound by quantiï¬ers, so the formula doesnâ€™t say anything determinate (it does not â€œexpress a complete thought,â€ as sentences are supposed to do). So how can we deï¬ne truth in a structure for formulas? We can do it only by relativizing it to an assignment of objects to variables. Satisfaction is the description of truth in a formula. Suppose we have two objects: a, which is large, and b, which is small. Then we can say that â€˜Larger(x, y)â€™ is true or â€œsatisfiedâ€ relative to the assignment {(x, a) ,( y, b)} , but false relative to the assignments {(x, b) , (y, a)} , {(x, a ), (y, a)} , and {(x, b ), (y, b)} . (Usually we will express this by saying that the assignment just speciï¬ed satisï¬es the formula.) This is the idea that the ï¬rst few deï¬nitions will make precise.</p><p>1.7.1</p><p>Show Definition</p><p>Leary notes that variable assignment functions need not be injective or bijective.</p><p>A function is injective if it does not give the same value for more than one argument. Recall that no function gives more than one value for a given argument. Putting these two things together, we see that an injective function must be one-to-one: for each argument, there is only one value, and for each value, there is only one argument. A function is said to be surjective if it is â€œonto,â€ that is, if every item in the range (or â€œcodomainâ€) of the function is a value of the function for some argument. A function is said to be bijective if it is both injective and surjective, that is, both one-to-one and onto. So the point here is that variable assignment functions need not determine a diï¬€erent value for each argument, and also need not take every element of A as its value for some argument.</p><p>We write â€˜f : A â†’ Bâ€™ to mean a function from A into B.</p><p>Function Into</p><p>s: Vars symbols of L â†’ elements of universe A</p><p>Leary gives us an example variable assignment function while working in the Language of number theory, using the standard structure.</p><p>Show s(vi) = i</p><p>With argument vÂ­i input into variable assignment function s, the value â€˜iâ€™, an element of universe A is output. This variable assignment function maps vi to element i. There are many possible variable assignment functions in this structure. He gives us another example:</p><p>Show sâ€™(vi) = the smallest prime number that does not divide i.</p><p>So far weâ€™re just assigning an object to each distinct variable. We arenâ€™t yet considering how we will use this assignment to discuss truth of a formula relative to an assignment. Next we introduce a notation for taking a variable assignment function s and changing it for a single variable.</p><p>1.7.2</p><p>Show Definition, example, definition</p><p>Consider the assignment function s that I informally mentioned earlier: {(x, a ), (y, b)}. Now suppose we want to modify this function so that both variables are assigned element a of the universe. We can write this modiï¬ed variable assignment function like this: s[x | b]. Then s(x) = a, but s[x | b](x) = b. On the other hand, s(y) = b and s[x | b](y) = b. Since the modiï¬cation aï¬€ects only the variable x, applying the modiï¬ed variable assignment function to y gives us the same results as applying the original variable assignment function to y.</p><p>We are gradually closing in on a deï¬nition of truth of a formula relative to an assignment. If we have a formula with some free variables, then assigning an element from the domain to each free variable will suï¬ƒce to determine the interpretation of all the terms. There are three kinds of terms: constants, variables, and function symbols followed by terms. Constants already have an interpretation assigned by the structure itself, so they are taken care of. The variables are taken care of by the variable assignment function s. This leaves only the complex terms constructed out of function symbols and other terms. But once the interpretation of constants and variables are taken care of, the complex terms are taken care of also. Each term ti that follows a function symbol is a constant, variable, or complex term. If it is a variable or a constant, it is taken care of already. If it is a complex term, we look at its constituent terms. Recursively following this procedure, we eventually reach function symbols all of whose terms have interpretations. Then we read the interpretation of the function symbol followed by those terms oï¬€ the structure. Then we return to the next higher level of our recursive process and proceed to examine the next term. Eventually we will have an interpretation for every term in our formula.</p><p>Now would be a good time to have an example, but I donâ€™t have one.</p><p>So we can take a variable assignment function, together with facts determined by the structure itself, and extend that variable assignment function to construct a more general term assignment function.</p><p>1.7.3</p><p>Show definition</p><p>Now we can (ï¬nally) deï¬ne what it is for a formula to be true relative to a variable assignment function. The usual term for truth relative to an assignment is satisfaction: we say that an assignment s satisï¬es a formula, or, in the language of the next deï¬nition, that a structure satisï¬es a formula with a particular assignment.</p><p>1.7.4</p><p>Show Definition</p><p>This deï¬nition is where we attach meanings to the logical symbols in L. The structure gives the meaning of the constant symbols, function symbols, and relation symbols, while the deï¬nition of satisfaction above essentially gives the meaning of the symbols that are common to all ï¬rst-order languages. These donâ€™t need to be given in the structure for the same reason that the logical symbols donâ€™t need to be listed when we specify a language: since they are common to all ï¬rst-order languages, we can leave them out of the structures, which merely give the semantics of the symbols that can change from language to language.</p><p>Notice that the notion of an x-modiï¬cation of a variable assignment function comes in handy in the fifth clause. If we have a quantiï¬ed sentence, we donâ€™t care what entity s assigns to occurrences of the variable that are bound by its quantiï¬er. For example, if we have the formula (âˆ€x)Larger(x, y) and an assignment function s = {(x, a ), (y, b)} and we want to know whether the assignment function satisï¬es the formula, then we need to appeal to the function s to ï¬nd how to interpret y, which is free, but the fact that s assigns a to x is irrelevant, because the quantiï¬er tells us that the whole formula is true only if the subformula after the quantiï¬er is true for every assignment of an object to x. The notation s[x | a] gives us a convenient way to consider assignments that keep all of the assignments of s except its assignment to x.</p><p>1.7.9</p><p>We are almost ready, ï¬nally, to say what it means for a sentence to be true in a structure. Iâ€™m going to go slightly out of order, starting with 1.7.9, and then working a bit backwards. First, we deï¬ne what it is for a structure to be a model of a formula.</p><p>Show Definition</p><p>The double turnstile symbol â€˜|=â€™ is rather versatile! The right-hand side can be either a structure, a formula or a set of formulas.</p><p>Informally, the basic idea is that a structure is a model of a formula if the formula must be true in the structure, i.e. if the formula comes out true no matter what terms you substitute for its free variables.</p><p>Of course, sentences are special cases of formulas. In the case of sentences, it makes no diï¬€erence what assignment function s we use. Why? Because sentences have no free variables, and assignment functions have no eï¬€ect on bound variables. So if there is any assignment function s for which Fraktur A |= Ï†[s] in the special case in which Ï† is a sentence, then, since it makes no diï¬€erence what assignment function we use, Ï† will be true for every assignment function, and hence we can simply say that Fraktur A |= Ï†, period.</p><p>To make it obvious when we are dealing with formulas that are also sentences, we will use a diï¬€erent Greek variable for sentences, â€˜Ïƒâ€™. (Notice the alliterative choice of Greek letters: phi, with its initial â€˜fâ€™ sound, for formulas, and sigma, with its initial â€˜sâ€™ sound, for sentences.)</p><p>1.7.5</p><p>Deï¬nition: If Ïƒ is a sentence, then we say that Ïƒ is true in Fraktur A if and only if Fraktur A |= Ïƒ, which in turn is the case if and only if there is any assignment function s for which Fraktur A |= Ïƒ[s].</p><p>Notice that a structure models a formula if and only if the sentence that results from preï¬xing to the formula universal quantiï¬ers binding all the free variables of the formula results in a sentence that is true in the structure.</p><p>1.8</p><p>Fraktur A = AxEy ~(x = y)</p><p>This sentence is true if the structure of Fraktur A is such that the domain A has at least two elements. If we replace variable x with variable u, then it is still true. Notice, however, that if we replace x with y, then it is always false, in any structure.</p><p>Substitutability relies upon substituting variables with terms in such a way that nothing bad will happen when we do. Substituting x with y, makes bad things happen. What would be true in a domain of 2 or more is now made false with this substitution. We must avoid this. In learning to avoid this problem, Leary provides us formal rules for when and where we can substitute.</p><p>1.8.1</p><p>Show definition</p><p>When u is x, then â€˜u with x replaced by tâ€™ is t.</p><p>When â€˜u is variable not equal to xâ€™ or when â€˜u is a constant symbolâ€™, then â€˜u with x replaced by tâ€™ is u.</p><p>With variables and constants handled, we are able to recursively define substitution for functions.</p><p>With the definition of substitution for variables, constants, and functions, we are then in a position to recursively define substitution into a formula, similar to how term assignment functions led to recursive definitions of satisfaction.</p><p>1.8.2</p><p>1.8</p><p>Fraktur A = AxEy ~(x = y)</p><p>This sentence is true if the structure of Fraktur A is such that the domain A has at least two elements. If we replace variable x with variable u, then it is still true. Notice, however, that if we replace x with y, then it is always false, in any structure.</p><p>Substitutability relies upon substituting variables with terms in such a way that nothing bad will happen when we do. Substituting x with y, makes bad things happen. We must avoid this. In avoiding this problem, Leary provides us formal rules for when and where we can substitute.</p><p>1.8.1</p><p>Show definition</p><p>When u is x, then â€˜u with x replaced by tâ€™ is t.</p><p>When â€˜u is variable not equal to xâ€™ or when â€˜u is a constant symbolâ€™, then â€˜u with x replaced by tâ€™ is u.</p><p>With variables and constants handled, we are able to recursively define substitution for functions.</p><p>With the definition of substitution for variables, constants, and functions, we are then in a position to recursively define substitution into a formula, similar to how term assignment functions led to recursive definitions of satisfaction.</p><p>1.8.2</p><p>Show Definition</p><p>1.8.3</p><p>Show Definition</p><p>1.9.1</p><p>Show Definition</p><p>If we restrict ourselves to sentences for a moment, we can say that one set of sentences Î” logically implies another set of sentences Î“ if and only if every structure in which all the sentences Î” are true is a structure in which all the sentences in Î“ are true. Equivalently, we can say that Î” logically implies Î“ if and only if every model of Î” is also a model of Î“.</p><p>Still another way to say the same thing: sometimes structures are called interpretations, and a model of a sentence is called an interpretation in which the sentence is true. So we can say that Î” logically implies Î“ iï¬€ every interpretation that makes all the sentences in Î” true also makes all the sentences in Î“ true.</p><p>It is a short step to the notion of a valid argument: an argument from a set of premises Î“ to a conclusion C is valid iï¬€ Î“ | = C.</p><p>The term â€˜validâ€™ is also used for a property of individual formulas. This usage is deï¬ned in Learyâ€™s Deï¬nition 1.9.2.</p><p>1.9.2</p><p>Show Definition</p></div>



</div>

</p>
</section>
</body>
</html>
