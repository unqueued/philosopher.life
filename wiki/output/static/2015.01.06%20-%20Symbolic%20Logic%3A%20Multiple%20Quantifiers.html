<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="generator" content="TiddlyWiki" />
<meta name="tiddlywiki-version" content="5.1.13" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="mobile-web-app-capable" content="yes"/>
<meta name="format-detection" content="telephone=no">
<link id="faviconLink" rel="shortcut icon" href="favicon.ico">
<link rel="stylesheet" href="static.css">
<title>2015.01.06 - Symbolic Logic: Multiple Quantifiers: â¦—h0p3's Wikiâ¦˜ â€” â€ â€ â€â€ â€1.2.20191101 ğ–¡¶ 

 Readme

</title>
</head>
<body class="tc-body">

<section class="tc-story-river">
<p><div class="tc-tiddler-frame tc-tiddler-view-frame tc-tiddler-exists   tc-tagged-Tulane " data-tags="Tulane" data-tiddler-title="2015.01.06 - Symbolic Logic: Multiple Quantifiers"><div class="tc-tiddler-title">
<div class="tc-titlebar">
<span class="tc-tiddler-controls">
<span class=" tc-reveal"><button aria-label="more" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fmore-tiddler-actions" title="More actions"></button><div class=" tc-reveal" hidden="true"></div></span><span class=" tc-reveal"><button aria-label="delete" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fdelete" title="Delete this tiddler">


</button></span><span class=" tc-reveal"><button aria-label="permalink" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fpermalink" title="Set browser address bar to a direct link to this tiddler"></button></span><span class=" tc-reveal"><span class=" tc-reveal"><button aria-label="info" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Finfo" title="Show information for this tiddler">
</button></span><span class=" tc-reveal" hidden="true"></span></span><span class=" tc-reveal"><span class=" tc-reveal" hidden="true"></span></span><span class=" tc-reveal"><button aria-label="new journal here" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fnew-journal-here" title="Create a new journal tiddler tagged with this one">





</button></span><span class=" tc-reveal"><button aria-label="close others" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose-others" title="Close other tiddlers"></button></span><span class=" tc-reveal"><button aria-label="edit" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fedit" title="Edit this tiddler"></button></span><span class=" tc-reveal"><button aria-label="close" class="tc-btn-invisible tc-btn-%24%3A%2Fcore%2Fui%2FButtons%2Fclose" title="Close this tiddler"></button></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span><span class=" tc-reveal" hidden="true"></span>
</span>

<a class="tc-tiddlylink tc-tiddlylink-resolves tc-popup-handle tc-popup-absolute" href="2015.01.06%2520-%2520Symbolic%2520Logic%253A%2520Multiple%2520Quantifiers.html">

<span class="tc-tiddler-title-icon" style="fill:;">

</span>



<h2 class="tc-title">
2015.01.06 - Symbolic Logic: Multiple Quantifiers
</h2>

</a>

</div>

<div class="tc-tiddler-info tc-popup-handle tc-reveal" hidden="true"></div>
</div><div class=" tc-reveal" hidden="true"></div>
<div class=" tc-reveal">
<div class="tc-subtitle">
Edited: 2018.10.30 23:59
</div>
</div><div class=" tc-reveal">
<div class="tc-tags-wrapper"><span class="tc-tag-list-item">
<span class="tc-tag-label tc-btn-invisible" draggable="true" style="background-color:;
fill:#ffffff;
color:#ffffff;">
 Tulane
</span>
<span class="tc-drop-down tc-reveal" hidden="true"></span></span></div>
</div>

<div class="tc-tiddler-body tc-reveal"><p>29</p><p>We will begin to look at multiple quantifiers. Weâ€™ll start with sentences that use the same quantifiers, and then weâ€™ll move onto sentences with mixed quantifiers. Letâ€™s consider a simple case to juice our intuitions.</p><p>Hereâ€™s an example of a sentence with multiple quantifiers:</p><p>â€œSome dog chased a cat.â€</p><p>âˆƒx âˆƒy (Dog(x) âˆ§ Cat(y) âˆ§ Chased(x, y))</p><p>Multiple Quantifiers Donâ€™t Guarantee Multiple Objects</p><p>It is tempting to read âˆƒx âˆƒy as saying there are two objects, x and y. But, this would be a mistake, since the variables x and y may pick out the same object. In our previous example, we know that x and y must be distinct because perhaps nothing can be both a cat and dog (unless we venture into some Nickelodeon cartoon, like CatDog).</p><p>Caution: Distinct variables do not necessarily entail distinct objects. For example:</p><p>âˆƒx âˆƒy (Tet(x) âˆ§ Tet(y))</p><p>â€œSomething is a tet, and something is a tet.â€</p><p>Recall that each quantifier will range over the entire domain. This sentence only requires one object in the domain (a single Tet) for the sentence to be true. x and y do not need to refer to two different things â€“ x and y can pick out the same object.</p><p>Consider a domain in which:</p><p>a is a tet</p><p>b is a cube</p><p>Given our example sentence, there are four possible substitutions of the variables:</p><p>&lt;x, y&gt;: &lt;a, a&gt;</p><p>&lt;a, b&gt;</p><p>&lt;b, a&gt;</p><p>&lt;b, b&gt;</p><p>Note that &lt;a, a&gt; (where a substitutes both x and y) satisfies our example quantified sentencesâ€™ constituent mere wff:</p><p>Tet(x) âˆ§ Tet(y)</p><p>Tet(a) âˆ§ Tet(a)</p><p>&lt;a, a&gt; satisfies the mere wff, again, because the substitution generates a sentence which is true. Hence, the original example existential sentence is true given the domain. It really doesnâ€™t matter if anything else is in the domain; just as long as there is a single tet, this sentence is true.</p><p>We can make a sentence to make sure that x and y must refer to different objects.</p><p>âˆƒx âˆƒy (Tet(x) âˆ§ Tet(y) âˆ§ x â‰  y)</p><p>This shows that x is not y, thus we know there must be at least 2 Tets in the domain for the sentence to be true.</p><p>I really want to drive this point home to you. Here is another way to think about it. Recall that an object may have multiple names.</p><p>Tet(a) âˆ§ Tet(b)</p><p>This sentence could be true in a world in which there is only one tet which is named a and b. Now, consider our original sentence:</p><p>âˆƒx âˆƒy (Tet(x) âˆ§ Tet(y))</p><p>Just as the truth of Tet(a) âˆ§ Tet(b) does not guarantee that there is more than one tet, neither does this quantified sentence. For just as a and b may name the same object, so too may the variables of the quantifiers âˆƒx and âˆƒy pick out the same object.</p><p>Hereâ€™s a neat thing which falls out of the fact that multiple quantifiers donâ€™t guarantee multiple objects. Consider this sentence:</p><p>âˆƒx (x = x)</p><p>â€œSomething is identical to itself.â€</p><p>This is a logical truth. Every object in every conceivable domain will make this sentence true. This sentence, however, logically implies another, yet similar logical truth:</p><p>âˆƒx âˆƒy (x = y)</p><p>â€œSomething is identical to something.â€</p><p>Depending on the domain, there may be many substitution combinations for x and y, but when x and y can pick out the same object, we can read the substitution as essentially pointing out that â€œsomething is identical to itself.â€ Again, I want to point out how the previous sentence cannot be translated as:</p><p>â€œSomething is identical to some other thing.â€</p><p>Since that would require this sentence in FOL:</p><p>âˆƒx âˆƒy (x = y âˆ§ x â‰  y)</p><p>This is logically impossible, of course. This sentence is necessarily false, as it should be. Since we have the conjunction of a sentence and the negation of it (remember we use infixed negation on the identity symbol).</p><p>Prenex and Aristotelian Forms</p><p>There are different, yet equivalent ways to write sentences with multiple quantifiers. Let us consider an example with equivalent prenex and Aristotelian forms.</p><p>â€œSome cube is left of a tetrahedron.â€</p><p>âˆƒx âˆƒy (Cube(x) âˆ§ Tet(y) âˆ§ LeftOf(x, y))</p><p>âˆƒx [Cube(x) âˆ§ âˆƒy (Tet(y) âˆ§ LeftOf(x, y))]</p><p>Both FOL sentences are equivalent translations of the English sentence.</p><p>The first translation is in prenex form. If you were to take the prenex FOL sentences and translate them back into English, you might not immediately get the original sentence. Youâ€™ll actually start out with something far more ugly and stilted.</p><p>â€œFor some x and for some y, x is a cube and y is a tet, and x is to the left of y.â€</p><p>We can try to naturalize our translation of the prenex form a bit. Sometimes naturalizing the translation takes some work, and you may want to do it in stages. So, we can take our initial translation of the prenex form and keep working on it:</p><p>â€œThere is some cube, x, and there is some tet, y, and x is to the left of y.â€</p><p>â€œSomething is a cube, and something is a tet, wherein the cube is to the left of the tet.â€</p><p>â€œSome cube is left of a tetrahedron.â€</p><p>Translation can be difficult. Thereâ€™s an art to it. You have to think about it.</p><p>The Aristotelian FOL sentence has one of the quantifiers embedded in the other. We might read it as:</p><p>â€œFor some x, x is a cube; for some y, y is a tet, and x is to the left of y.â€</p><p>We can manage to re-interpret or naturalize our initial readings:</p><p>â€œSome cube, x, is to the left of some tet, y.â€</p><p>â€œSome cube is to the left of some tet.â€</p><p>Youâ€™ll notice that this second translation follows the Aristotelian form of â€œSome Pâ€™s are Qâ€™s.â€ Sometimes it is easier to translate or breakdown a sentence in the second form rather than the prenex.</p><p>Part of the reason it is easier is because the embedded sentence can be read as a single unit, â€œx is to the left of a tet,â€ where that tet is y. Letâ€™s call that unit, G. Consider our original sentence, but replacing the single-unit embedded statement with G, we can see this exactly like our Aristotelian form:</p><p>â€œSome cube is G(x).â€</p><p>âˆƒx [Cube(x) âˆ§ G(x)]</p><p>We want G(x) to say that â€œx is to the left of a tetrahedron.â€ We need G(x) to have a new quantifier and variable to express this nature of this tetrahedron. Hence, G(x) just is:</p><p>âˆƒy (Tet(y) âˆ§ LeftOf(x, y))</p><p>Thus, we can read this Aristotelian form as, â€œsome cube, x, is to the left of a tetrahedron, y.â€</p><p>We should also consider an example with multiple universal quantifiers:</p><p>â€œEvery cube is to the left of every tetrahedron.â€</p><p>âˆ€x âˆ€y [(Cube(x) âˆ§ Tet(y)) â†’ LeftOf(x, y)]</p><p>âˆ€x [Cube(x) â†’ âˆ€y (Tet(y) â†’ LeftOf(x, y))]</p><p>Like our previous examples, we might have a chain of equivalent, yet more natural-sounding English translations:</p><p>â€œFor all x and for all y, if both x is a cube and y is a tet, then x is to the left of y.â€</p><p>â€œEvery cube, x, and every tet, y, are such that x is to the left of y.â€</p><p>â€œEvery cube is to the left of every tetrahedron.â€</p><p>We can read the Aristotelian version as:</p><p>â€œFor all x, if x is a cube, then for all y, if y is a tet, then x is to the left of y.â€</p><p>â€œEvery cube, x, is to the left of every tet, y.â€</p><p>â€œEvery cube is to the left of every tetrahedron.â€</p><p>The Aristotelian form has a similar breakdown as the previous Aristotelian example. We can think of it as:</p><p>â€œEvery cube is H(x).â€</p><p>âˆ€x [Cube(x) â†’ H(x)]</p><p>Where H(x) is:</p><p>âˆ€y (Tet(y) â†’ LeftOf(x, y))</p><p>This wff says, â€œx is to the left of every tet, y.â€ Hence, we can read the Aristotelian form as â€œEvery cube, x, is to the left of every tet, y.â€</p><p>The Aristotelian form promotes the practice of breaking the sentence down, and so it might be easier to use. Ultimately, if you want, you can avoid the prenex form in many cases, and stick to the easier to comprehend Aristotelian form.</p><p>Homework: 11.1-11.6</p><p>Mixed Quantifiers</p><p>Weâ€™ve looked at examples of having the same kind of quantifier in multiples. We are going to look at mixed quantifiers now.</p><p>â€œEvery cube is left of a tetrahedron.â€</p><p>This clearly has an Aristotelian form:</p><p>âˆ€x (P(x) â†’ Q(x))</p><p>Where P(x) means â€œx is a cubeâ€ and Q(x) means â€œx is left of a tetrahedron.â€ Just as in our previous examples, where that tet is y, we can substitute Q(x) with:</p><p>âˆƒy (Tet(y) âˆ§ LeftOf(x, y))</p><p>Youâ€™ll note this embedded sentence actually is an Aristotelian form as well. Further, substituting P(x) with the appropriate FOL sentence, we arrive at:</p><p>âˆ€x [Cube(x) â†’ âˆƒy (Tet(y) âˆ§ LeftOf(x, y))]</p><p>Order of Quantifiers</p><p>When quantifiers in the same sentence are of the same quantity (all universal or all existential), the order in which they occur generally does not matter. But when they are mixed, the order in which they occur becomes crucial.</p><p>âˆ€x âˆ€y Likes(x, y) â‡” âˆ€y âˆ€x Likes(x, y)</p><p>â€œEvery x likes every y.â€ â‡” â€œEvery y is liked by every x.â€</p><p>â‡” â€œEveryone likes everyone.â€</p><p>âˆƒx âˆƒy Likes(x, y) â‡” âˆƒy âˆƒx Likes(x, y)</p><p>â€œSome x likes some y.â€ â‡” â€œSome y is liked by some x.â€</p><p>â‡” â€œSomeone is liked by someone.â€</p><p>Multiples of the same quantifiers are easy. Mixed are more difficult. Consider this example:</p><p>âˆ€x âˆƒy Likes(x, y)</p><p>âˆƒy âˆ€x Likes(x, y)</p><p>These are not equivalent sentences. We can read the first sentence as, â€œEvery x likes some y.â€ Essentially, it says, â€œeveryone likes someone,â€ but allows for the possibility that different people have different likes.</p><p>Consider a world with 4 people: A, B, C, and D, wherein:</p><p>A likes B</p><p>B likes C</p><p>C likes D</p><p>D likes A</p><p>This world would make the first sentence true. Everyone likes someone. Note, however, that it doesnâ€™t say who they like. That someone could be anyone.</p><p>The second sentence, however, says something much stronger. We can read it as â€œSome y is liked by every x.â€ Essentially, it says, â€œsomeone is liked by everyone.â€ For example, maybe:</p><p>A, B, C, and D all like A</p><p>This sentence not only makes the first sentence true, but also the second.</p><p>Cool fact, this stronger, second sentence logically implies the first. If â€œsomeone is liked by everyone,â€ then of course, â€œeveryone likes someone.â€</p><p>In general, a âˆƒâˆ€ sentence logically implies its âˆ€âˆƒ counterpart. Letâ€™s see another example:</p><p>âˆ€x âˆƒy (x = y)</p><p>âˆƒy âˆ€x (x = y)</p><p>These sentences arenâ€™t equivalent. The first says, â€œEvery x is identical to some yâ€ or â€œEverything is identical to something.â€ Since in every world, every object is self-identical, this sentence is a logical truth. And, frankly, every sentence logically implies a logical truth. So the general rule of thumb I gave you holds here, even without understanding what the second sentence even means.</p><p>The second says, â€œSome y is identical to every xâ€ or â€œSomething is identical to everything.â€ This is a far stronger and more particular claim. It can only be true in a domain with one object. Obviously it implies the first sentence, but the first sentence doesnâ€™t imply this second sentence.</p><p>In any case, these mixed quantifier sentences are all distinct, and they arenâ€™t equivalent. Some are implied by others, but not the other way around. Order clearly matters when your quantifiers are different.</p><p>Homework: 11.8-11.15</p><p>Step-by-Step Method of English to FOL Translation</p><p>Identify quantifier expressions.</p><p>Find the general form.</p><p>Isolate and translate the embedded wffs.</p><p>Plug these wffs into the general form.</p><p>For example:</p><p>â€œEach cube is to the left of a tetrahedron.â€</p><p>First, identify the quantifier expressions:</p><p>â€œEach cubeâ€ and â€œa tetrahedronâ€</p><p>Universal and Existential</p><p>Find the general form:</p><p>â€œAll Pâ€™s are Qâ€™sâ€ â‡” âˆ€x (P(x) â†’ Q(x))</p><p>Where P(x) is concerned with â€œeach cubeâ€ and Q(x) is concerned with those cubes being â€œleft of a tetrahedron.â€</p><p>Now isolate and translate the embedded wffs:</p><p>â€œx is a cubeâ€ â‡” Cube(x)</p><p>â€œx is left of a tetrahedronâ€ â‡” âˆƒy(Tet(y) âˆ§ LeftOf(x, y))</p><p>Plugâ€™nâ€™Play:</p><p>âˆ€x[Cube(x) â†’ âˆƒy(Tet(y) âˆ§ LeftOf(x, y))]</p><p>Voila. Letâ€™s try another example:</p><p>â€œSome cube that adjoins a dodecahedron is larger than every tetrahedron.â€</p><p>First, go through the sentence to identify the quantifier expressions.</p><p>â€œSome cubeâ€ and â€œa dodecahedronâ€ and â€œevery tetrahedronâ€</p><p>So, two existential expressions and one universal. Now, we find the general structure of the sentence. In this case, itâ€™s one of the Aristotelian forms (sometimes it wonâ€™t be):</p><p>â€œSome Pâ€™s are Qâ€™sâ€ â‡” âˆƒx (P(x) âˆ§ Q(x))</p><p>Where P(x) is concerned with â€œSome cube that adjoins a dodecahedronâ€ and Q(x) concerned with that cube being â€œlarger than every tetrahedron.â€</p><p>Now we isolate the embedded wffs and translate them.</p><p>â€œx is a cube that adjoins a dodecahedronâ€ â‡” Cube(x) âˆ§ âˆƒy (Dodec(y) âˆ§ Adjoins(x, y))</p><p>â€œx is larger than every tetrahedronâ€ â‡” âˆ€y (Tet(y) â†’ Larger(x, y))</p><p>Finally, plug these wffs into our overall form âˆƒx (P(x) âˆ§ Q(x)) in place of the two conjuncts P(x) and Q(x). This yields our completed translation:</p><p>âˆƒx [Cube(x) âˆ§ âˆƒy (Dodec(y) âˆ§ Adjoins(x, y)) âˆ§ âˆ€y (Tet(y) â†’ Larger(x, y))]</p><p>Letâ€™s try another example.</p><p>â€œNo cube to the right of a tetrahedron is to the left of a larger dodecahedron.â€</p><p>We can begin by identifying the quantifier expressions and then determining the general structure of the sentence. It has the form:</p><p>â€œNo Cubeâ€ and â€œa tetrahedronâ€ and â€œa dodecahedronâ€</p><p>Either universal or existential, and two existentials</p><p>The form:</p><p>â€œNo Pâ€™s are Qâ€™sâ€ â‡”	âˆ€x(P(x) â†’ Â¬Q(x))</p><p>Where P(x) is concerned with â€œcubes to the right of a tetrahedronâ€ and Q(x) with cubes not being â€œleft of a larger dodecahedron.â€</p><p>My intuitions make it easier to translate this using the negated existential form, Â¬âˆƒx(P(x) âˆ§ Q(x)), however, that may not be the case for you. Weâ€™ll try it first using the universal.</p><p>Now we isolate the embedded wffs and translate:</p><p>The Antecedent:</p><p>â€œx is a cube to the right of a tetrahedronâ€ â‡” Cube(x) âˆ§ âˆƒy (Tet(y) âˆ§ RightOf(x, y))</p><p>The Consequent:</p><p>â€œx is to the left of a larger dodecahedronâ€</p><p>Before we can begin to translate this embedded wff, we must decide what the dodecahedron is being said to be larger than. There seem to be two possibilities:</p><p>(1) â€œa dodecahedron larger than xâ€</p><p>(2) â€œa dodecahedron larger than the tetrahedron mentioned in the antecedentâ€</p><p>The sentence seems genuinely ambiguous between these possibilities, although (1) seems more likely to my ears, so we will go with that reading. Thus:</p><p>â€œx is to the left of a dodecahedron that is larger than xâ€ â‡”</p><p>âˆƒy (Dodec(y) âˆ§ LeftOf(x, y) âˆ§ Larger(y, x))</p><p>Now we plugâ€™nâ€™play our P(x) and Q(x)</p><p>âˆ€x [(Cube(x) âˆ§ âˆƒy (Tet(y) âˆ§RightOf(x, y))) â†’ Â¬âˆƒy (Dodec(y) âˆ§LeftOf(x, y) âˆ§ Larger(y, x))]</p><p>Letâ€™s quickly work through a few more examples.</p><p>â€œEvery small cube is in back of a large cube.â€</p><p>Quantifier expressions: â€œEvery small cubeâ€ and â€œa large cubeâ€</p><p>Form: âˆ€x(P(x) â†’ Q(x))</p><p>âˆ€x [(Small(x) âˆ§ Cube(x)) â†’ in-back-of-a-large-cube)]</p><p>âˆ€x [(Small(x) âˆ§ Cube(x)) â†’ âˆƒy (Large(y) âˆ§ Cube(y) âˆ§ BackOf(x, y))]</p><p>Another example:</p><p>â€œSome cube is in front of every tetrahedron.â€</p><p>Quantifier expressions: â€œSome cubeâ€ and â€œevery tetrahedronâ€</p><p>Form: âˆƒx (P(x) âˆ§ Q(x))</p><p>âˆƒx (Cube(x) âˆ§ is in front of every tet)</p><p>âˆƒx [Cube(x) âˆ§ âˆ€y (Tet(y) â†’ Front(x, y))]</p><p>Another example:</p><p>â€œEverything to the right of a large cube is small.â€</p><p>Quantifier expressions: â€œEverythingâ€ and â€œa cubeâ€</p><p>Form: âˆ€x(P(x) â†’ Q(x))</p><p>âˆ€x (x is to the right of a large cube â†’ Small(x))</p><p>âˆ€x [âˆƒy(Large(y) âˆ§ Cube(y) âˆ§ RightOf(x, y)) â†’ Small(x)]</p><p>Another example:</p><p>â€œAnything with nothing in back of it is a cube.â€</p><p>Quantifier expressions: â€œAnythingâ€ and â€œnothingâ€ - Notice that â€œis a cubeâ€, the determiner â€œaâ€ doesnâ€™t make this a quantified expression.</p><p>Form: âˆ€x(P(x) â†’ Q(x))</p><p>âˆ€x(if nothing is in back of x â†’ Cube(x))</p><p>âˆ€x(Â¬âˆƒy(BackOf(y, x) â†’ Cube(x))</p><p>Homework: 11.16-11.17</p><p>Paraphrasing English</p><p>There are times when the step-by-step method cannot be applied directly. This happens frequently in cases in which the quantifier word something is used with universal force. For example:</p><p>â€œIf something is a cube, it is not a tetrahedron.â€</p><p>The tip-off that the â€œsomethingâ€ here is a universal quantifier is the occurrence of the pronoun â€œitâ€ in the consequent. This â€œitâ€ functions in English as a variable, so it must be bound by a quantifier. But, the only quantifier around is the one in the antecedent. If we make it existential and include the variable â€œitâ€ in its scope, we would get:</p><p>â€œThere is something such that, if is a cube, it is not a tetrahedron.â€</p><p>âˆƒx (Cube(x) â†’ Â¬Tet(x))</p><p>But, this sentence is too weak, as weâ€™ve already seen, to say what the English sentence says. The existence of a single non-cube, for example, makes it true. But, if we restrict the scope of âˆƒx to the antecedent, we get:</p><p>âˆƒx Cube(x) â†’ Â¬Tet(x)</p><p>But, this mere wff is not a sentence (the x in Tet(x) is free). The step-by-step method seems to have failed us. What we must do, instead, is to continuously paraphrase the original sentence in a way that gives the quantifier a large scope. When we do this, we see that the quantifier is actually universal:</p><p>â€œIf anything is a cube, it is not a tetrahedron.â€</p><p>â€œFor anything you like, if it is a cube, it is not a tetrahedron.â€</p><p>â€œNo cube is a tetrahedron.â€</p><p>âˆ€x (Cube(x) â†’ Â¬Tet(x))</p><p>Letâ€™s look at another example:</p><p>â€œIf a freshman takes a logic class, then he or she must be smart.â€</p><p>If you attempt to translate step by step, you get:</p><p>âˆƒx(Freshman(x) âˆ§ âˆƒy(LogicClass(y) âˆ§ Takes(x, y))) â†’ Smart(x)</p><p>This is not a sentence since it has a free variable, â€œSmart(x)â€ â€“ hence, we must paraphrase it.</p><p>â€œEvery freshman who takes a logic class is smartâ€</p><p>This translates nicely:</p><p>âˆ€x[(Freshman(x) âˆ§ âˆƒy(LogicClass(y) âˆ§ Takes(x, y))) â†’ Smart(x)]</p><p>Donkey Sentences</p><p>The classic example.</p><p>â€œEvery farmer who owns a donkey beats it.â€</p><p>The difficulty with such sentences is that they resemble ones in which the phrase â€œa donkeyâ€ is properly treated as an existential quantifier.</p><p>â€œEvery farmer who owns a donkey buys hay.â€</p><p>This goes into FOL straight forwardly as:</p><p>âˆ€x [(Farmer(x) âˆ§ âˆƒy (Donkey(y) âˆ§ Owns(x, y)) â†’ BuysHay(x))]</p><p>Note that the scope of the existential quantifier stops at the end of the antecedent. If we try to translate the classic donkey sentence this way, we get:</p><p>âˆ€x [(Farmer(x) âˆ§ âˆƒy (Donkey(y) âˆ§ Owns(x, y)) â†’ Beats(x, y))]</p><p>This is a mere wff, since the y in the consequent is free. We can see this by translating the wff back into English:</p><p>â€œEvery farmer who owns a donkey beats y.â€</p><p>In order to have a sentence (a wff with no free variables) we must make sure that the y variable in Beats(x, y) is bound by the quantifier (â€œa donkeyâ€) in the antecedent. This means we must paraphrase the original English sentence, perhaps in one of the following ways:</p><p>â€œAny farmer who owns any donkey beats it.â€</p><p>â€œEvery farmer is such that any donkey he owns is beaten by him.â€</p><p>â€œEvery farmer beats every donkey he owns.â€</p><p>This makes clear that the original sentence contains two universal quantifiers:</p><p>âˆ€x [Farmer(x) â†’ âˆ€y {(Donkey(y) âˆ§ Owns(x, y)) â†’ Beats(x, y)}]</p><p>In LPL, a slightly different (but equivalent) translation is offered:</p><p>âˆ€x [Donkey(x) â†’ âˆ€y {(Farmer(y) âˆ§ Owns(y, x)) â†’ Beats(y, x)}]</p><p>Homework: 11.18-11.21</p><p>Ambiguity and Context Sensitivity</p><p>Sentences containing both universal and existential quantifiers can be ambiguous, depending on the scope the quantifiers receive.</p><p>â€œSome man has been calling Becky every hour.â€</p><p>When the existential quantifier is given wide scope, we get what is called the â€œstrongâ€ reading:</p><p>âˆƒx [Man(x) âˆ§ âˆ€y (Hour(y) â†’ Calls(x, becky, y))]</p><p>This FOL sentence suggests that Becky is being harassed by a single persistent (and unwanted) caller. On the other hand, if we take the English sentence to mean merely that Becky is popular, and has been receiving calls from many different interested creepers or gentlemen (take your pick), the right way to put it would be this (the â€œweakâ€ reading):</p><p>âˆ€y [Hour(y) â†’ âˆƒx (Man(x) âˆ§ Calls(x, becky, y))]</p><p>The weak reading is a logical consequence of the strong reading, but not conversely.</p><p>Youâ€™ll note that the second translation ends up repositioning the â€œevery hourâ€ quantified expression at the beginning, as the overall structure.</p><p>In other cases, the context makes the weak reading obviously the intended one. Consider the following sentence (attributed to the showman P. T. Barnum):</p><p>â€œThereâ€™s a sucker born every minute.â€</p><p>The strong reading here is obviously inappropriate:</p><p>âˆƒx [Sucker(x) âˆ§ âˆ€y (Minute(y) â†’ BornAt(x, y))]</p><p>The trouble with this FOL translation is that it says that some unfortunate individual has the property of being born (again, and again) at each and every minute. What the original sentence obviously intended was the weaker claim, that no matter what minute you pick, some sucker is being born then (a different sucker at each succeeding minute, of course, since each of us is born only once). Hereâ€™s the FOL version of the intended (weak) reading:</p><p>âˆ€y [Minute(y) â†’ âˆƒx (Sucker(x) âˆ§ BornAt(x, y))]</p><p>Ralph Waldo Emerson Ambiguity</p><p>In our next example, there are multiple sources of ambiguityâ€”not just the scope of the quantifiers, but their quantity.</p><p>â€œEverybody loves a lover.â€</p><p>Weâ€™ll start questions that arise from the ambiguity of two notions.</p><p>Order of the quantifiers</p><p>Does â€œeverybodyâ€ have wide scope, or does â€œa loverâ€ have wide scope?</p><p>Which of the two quantifiers has wide scope?</p><p>Without context, it seems weâ€™ll have to keep both options open.</p><p>Quantity of the quantifiers</p><p>Is â€œa loverâ€ an existential quantifier (â€œsome loverâ€) or universal (â€œevery loverâ€)?</p><p>Without a context, itâ€™s hard to tell, so weâ€™ll have to keep both options open.</p><p>This would seem to give us, at least in the abstract, four possibilities. We can represent them (temporarily) in the following slightly unorthodox way:</p><p>1. âˆƒ lover y âˆ€ person x: x loves y</p><p>2. âˆ€ person x âˆƒ lover y: x loves y</p><p>3. âˆ€ lover y âˆ€ person x: x loves y</p><p>4. âˆ€ person x âˆ€ lover y: x loves y</p><p>Since (3) and (4) do not involve mixed quantifiers, they are clearly equivalent. (3) says that â€œevery lover is loved by every person,â€ and (4) says that â€œevery person loves every lover.â€ So we only need to consider one of themâ€”weâ€™ll drop (4) from consideration. But the other three are still in the running:</p><p>says that â€œthere is some lover, y, such that everyone loves y.â€</p><p>says that â€œfor each person, x, there is a lover, y, such that x loves y.â€</p><p>This leaves open the possibility, which (1) does not, that different people might love different lovers</p><p>says that â€œevery lover is loved by everyone.â€</p><p>This seems to have been the original intention of the poet Ralph Waldo Emerson when he wrote â€œHereâ€™s to the happy man: All the world loves a lover.â€ That is, no matter who you are, all you have to do is to be a lover, and everyone will love you.</p><p>So (3) seems to be the favored reading of this potentially ambiguous sentence.</p><p>Homework: 11.24-11.26</p><p>Prenex Form</p><p>For many purposes, it is advantageous to have an FOL sentence in prenex form. Furthermore, every FOL sentence has an equivalent sentence (in fact, many equivalent sentences) in prenex form. In this section, we discuss methods for putting sentences into prenex form. But first, letâ€™s refresh ourselves on why trying to put sentences directly into prenex form is likely to lead to error.</p><p>Consider this example of sentences which might appear equivalent, but arenâ€™t:</p><p>âˆ€x Cube(x) â†’ âˆ€y Large(y) â€œIf everything is a cube, then everything is largeâ€</p><p>âˆ€x âˆ€y (Cube(x) â†’ Large(y)) â€œEverything is such that if itâ€™s a cube, then everything is largeâ€</p><p>The second sentence is in prenex form, but it is not equivalent to the first sentence. We canâ€™t just pull the inside quantifier out. To convert to prenex form, we must remember the equivalences we learned in chapter 10:</p><p>âˆƒx (Q(x) â†’ P) â‡” âˆ€x Q(x) â†’ P</p><p>âˆƒx (P â†’ Q(x)) â‡”	P â†’ âˆ€x Q(x)</p><p>Remember, these equivalences require that P is either a sentence or a wff containing no free occurrence of x.</p><p>We apply the first equivalence to our first sentence:</p><p>âˆƒx (Q(x) â†’ P) â‡” âˆ€x Q(x) â†’ P</p><p>âˆƒx (Cube(x) â†’ âˆ€y Large(y)) â‡”	âˆ€x Cube(x) â†’ âˆ€y Large(y)</p><p>Note how Q(x) is Cube(x). We pull the universal quantifier off of the antecedent and change it to an existential quantifier whose scope is the entire conditional. Next, we will apply the second equivalence to sentence our new sentence:</p><p>âˆ€x (P â†’ Q(x)) â‡”	P â†’ âˆ€x Q(x)</p><p>âˆƒx âˆ€y (Cube(x) â†’ Large(y)) â‡” âˆƒx (Cube(x) â†’ âˆ€y Large(y))</p><p>Note how Q(x) is Large(y). Here we simply moved the universal quantifier, âˆ€y, from the consequent to the entire conditional. Note that in applying this equivalence, P is the wff Cube(x), which contains no free occurrences of y, the variable in the exported quantifier.</p><p>Thus, the prenex form of âˆ€x Cube(x) â†’ âˆ€y Large(y) is not âˆ€x âˆ€y (Cube(x) â†’ Large(y)), but rather âˆƒx âˆ€y (Cube(x) â†’Large(y)). We can use Fitchâ€™s FO Con to further convince ourselves of this.</p><p>Rules for Converting to Prenex</p><p>To convert an FOL sentence to prenex form, we make use of these equivalences that we learned in chapter 10:</p><p>DeMorgan laws for quantifiers</p><p>Distributing âˆ€ through âˆ§</p><p>Distributing âˆƒ through âˆ¨</p><p>Null quantification</p><p>Replacing bound variables</p><p>In addition, we will need to use some of the handy truth-functional equivalences we learned in</p><p>Â§ 8.1, especially to get rid of biconditionals:</p><p>P â†”Q â‡” ((P â†’Q) âˆ§ (Q â†’P) )</p><p>P â†”Q â‡” ((P âˆ§ Q) âˆ¨ (Â¬P âˆ§ Â¬Q))</p><p>The general strategy is to work from the inside out, moving quantifiers â€œoutwardâ€ so that they get larger in scope. Since all of our quantifiers will appear at the beginning of our ultimate sentence, we must be sure that no quantifier gets reused (e.g., we cannot have both âˆ€xand âˆƒx); each time we have a quantifier that repeats a variable, we will have to change to a new variable. We will definitely need to get rid of biconditionals, and it is sometimes useful to get rid of conditionals, as well. The procedure is best illustrated by examples, to which we now turn.</p><p>Letâ€™s show a conversion into prenex:</p><p>âˆ€x Cube(x) âˆ¨ Â¬âˆƒx Tet(x)</p><p>The strategy will be to drive the negation sign through the quantifier Â¬âˆƒx, converting it to âˆ€xÂ¬ (appealing to DeMorgan laws for quantifiers), then rewrite the second quantifier with a new variable, y (replacing bound variables), then pull the quantifiers to the outside (null quantification). Weâ€™ll do this one step at a time.</p><p>âˆ€x Cube(x) âˆ¨ Â¬âˆƒx Tet(x) â‡” âˆ€x Cube(x) âˆ¨ âˆ€x Â¬Tet(x) DeMorganâ€™s</p><p>â‡”	âˆ€x Cube(x) âˆ¨ âˆ€y Â¬Tet(y) Replacing bound var.</p><p>â‡” âˆ€x (Cube(x) âˆ¨ âˆ€y Â¬Tet(y)) Null Quantification</p><p>â‡” âˆ€x âˆ€y (Cube(x) âˆ¨ Â¬Tet(y)) Null Quantification</p><p>Notice that we might have performed the last two steps (pulling out the universal quantifiers) in reverse order. If we had, we would have ended up with this (equivalent) prenex form:</p><p>âˆ€y âˆ€x (Cube(x) âˆ¨ Â¬Tet(y))</p><p>Letâ€™s consider a nasty soup-to-nuts example, where we start with an English sentence, translate into the FOL Aristotelian form, and then convert to prenex.</p><p>â€œNo cube that adjoins a tetrahedron is back of every dodecahedron.â€</p><p>We make no effort to go directly to prenex form. Instead, we translate into FOL using the step-by-step method:</p><p>âˆ€x(x is a cube-that-adjoins-a-tetrahedron â†’ Â¬ x is back-of-every-dodecahedron)</p><p>âˆ€x((x is a cube âˆ§ âˆƒy (y is a tetrahedron âˆ§ x adjoins y)) â†’ Â¬ x is back-of-every-dodecahedron)</p><p>âˆ€x((x is a cube âˆ§ âˆƒy (y is a tetrahedron âˆ§ x adjoins y)) â†’ Â¬ âˆ€z(z is a dodecahedron â†’ x is back of z))</p><p>âˆ€x {[Cube(x) âˆ§ âˆƒy (Tet(y) âˆ§ Adjoins(x, y))] â†’ Â¬âˆ€z (Dodec(z) â†’ BackOf(x, z))}</p><p>Now we convert to prenex form. First, we drive the negation sign inside the scope of the quantifier âˆ€z:</p><p>âˆ€x {[Cube(x) âˆ§ âˆƒy (Tet(y) âˆ§ Adjoins(x, y))] â†’ âˆƒz Â¬(Dodec(z) â†’ BackOf(x, z))}</p><p>Next, we look at the conjunction that is the antecedent of the first conditional:</p><p>[Cube(x) âˆ§ âˆƒy (Tet(y) âˆ§ Adjoins(x, y))]</p><p>We then apply one of the â€œnull quantificationâ€ equivalences. This allows us to pull the existential quantifier out:</p><p>âˆƒx (P âˆ§ Q(x)) â‡” P âˆ§ âˆƒx Q(x)</p><p>âˆƒy [Cube(x) âˆ§ (Tet(y) âˆ§ Adjoins(x, y))] â‡”	Cube(x) âˆ§ âˆƒy (Tet(y) âˆ§ Adjoins(x, y))</p><p>Replacing this in the entire sentence yields:</p><p>âˆ€x {[Cube(x) âˆ§ âˆƒy (Tet(y) âˆ§ Adjoins(x, y))] â†’ âˆƒz Â¬(Dodec(z) â†’ BackOf(x, z))} â‡”</p><p>âˆ€x {âˆƒy [Cube(x) âˆ§ (Tet(y) âˆ§ Adjoins(x, y))] â†’ âˆƒz Â¬(Dodec(z) â†’ BackOf(x, z))}</p><p>The wff in the scope of the initial universal quantifier âˆ€x is:</p><p>âˆƒy [Cube(x) âˆ§ (Tet(y) âˆ§ Adjoins(x, y))] â†’ âˆƒz Â¬(Dodec(z) â†’ BackOf(x, z))</p><p>And this is of the form of the first of the following, and equivalent to the second:</p><p>âˆƒy Q(y) â†’ P â‡” âˆ€y (Q(y) â†’ P)</p><p>So we pull out the existential quantifier and change it to a universal, and embed the resulting wff inside the scope of âˆ€x:</p><p>âˆ€x {âˆƒy [Cube(x) âˆ§ (Tet(y) âˆ§ Adjoins(x, y))] â†’ âˆƒz Â¬(Dodec(z) â†’ BackOf(x, z))} â‡”</p><p>âˆ€x âˆƒy {[Cube(x) âˆ§ (Tet(y) âˆ§ Adjoins(x, y))] â†’ âˆƒz Â¬(Dodec(z) â†’ BackOf(x, z))}</p><p>Finally, the existential quantifier in the consequent can be moved to the outside of the conditional (but inside the other quantifiers!). Recall this null quantification:</p><p>âˆƒx (P â†’ Q(x)) â‡” P â†’ âˆƒx Q(x)</p><p>Applying this yields:</p><p>âˆ€x âˆƒy {[Cube(x) âˆ§ (Tet(y) âˆ§ Adjoins(x, y))] â†’ âˆƒz Â¬(Dodec(z) â†’ BackOf(x, z))}</p><p>âˆ€x âˆƒy âˆƒz {[Cube(x) âˆ§ (Tet(y) âˆ§ Adjoins(x, y))] â†’ Â¬(Dodec(z) â†’ BackOf(x, z))}</p><p>Homework: 11.37-11.39
</p></div>



</div>

</p>
</section>
</body>
</html>
